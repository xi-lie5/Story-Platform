<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>改进版故事生成系统API文档</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            line-height: 1.6;
            color: #333;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f5f5f5;
        }
        .container {
            background-color: #fff;
            padding: 40px;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        h1, h2, h3, h4 {
            color: #2c3e50;
            margin-top: 30px;
        }
        h1 {
            text-align: center;
            border-bottom: 2px solid #3498db;
            padding-bottom: 20px;
            margin-bottom: 40px;
        }
        h2 {
            border-left: 5px solid #3498db;
            padding-left: 15px;
            margin-top: 50px;
        }
        h3 {
            border-bottom: 1px solid #eee;
            padding-bottom: 10px;
        }
        .endpoint {
            background-color: #f8f9fa;
            padding: 20px;
            margin: 20px 0;
            border-radius: 5px;
            border-left: 4px solid #3498db;
        }
        .method {
            display: inline-block;
            padding: 5px 10px;
            border-radius: 3px;
            font-weight: bold;
            margin-right: 10px;
        }
        .get { background-color: #28a745; color: white; }
        .post { background-color: #007bff; color: white; }
        .put { background-color: #ffc107; color: #212529; }
        .delete { background-color: #dc3545; color: white; }
        code {
            font-family: 'Courier New', Courier, monospace;
            background-color: #f1f1f1;
            padding: 2px 5px;
            border-radius: 3px;
            font-size: 0.9em;
        }
        pre {
            background-color: #f8f9fa;
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto;
            border: 1px solid #e1e4e8;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
        }
        th, td {
            border: 1px solid #ddd;
            padding: 12px;
            text-align: left;
        }
        th {
            background-color: #3498db;
            color: white;
        }
        tr:nth-child(even) {
            background-color: #f2f2f2;
        }
        .note {
            background-color: #fff3cd;
            padding: 15px;
            border-radius: 5px;
            border-left: 4px solid #ffc107;
            margin: 20px 0;
        }
        .warning {
            background-color: #f8d7da;
            padding: 15px;
            border-radius: 5px;
            border-left: 4px solid #dc3545;
            margin: 20px 0;
        }
        .success {
            background-color: #d4edda;
            padding: 15px;
            border-radius: 5px;
            border-left: 4px solid #28a745;
            margin: 20px 0;
        }
        .flow-diagram {
            background-color: #f8f9fa;
            padding: 20px;
            border-radius: 5px;
            border: 1px solid #ddd;
            margin: 20px 0;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>改进版故事生成系统API文档</h1>
        
        <h2>1. 系统概述</h2>
        <p>本文档描述了改进后的故事生成系统API设计，重点解决了故事节点关系处理、临时ID映射、批量操作等核心问题。系统支持两种主要模式：</p>
        <ul>
            <li><strong>编辑模式</strong>：作者创建和管理故事节点及连接关系</li>
            <li><strong>阅读模式</strong>：用户按章节阅读交互式故事</li>
        </ul>
        
        <h2>2. 数据模型</h2>
        
        <h3>2.1 Story（故事）模型</h3>
        <pre>
const storySchema = new mongoose.Schema({
  title: { 
    type: String, 
    required: [true, '故事标题必填'], 
    trim: true, 
    maxlength: [100, '故事标题不能超过100个字符'] 
  },
  author: { 
    type: mongoose.Schema.Types.ObjectId, 
    ref: 'User', 
    required: [true, '故事作者ID必填'], 
    index: true 
  },
  category: { 
    type: mongoose.Schema.Types.ObjectId, 
    ref: 'Category', 
    required: [true, '分类ID必填'], 
    index: true 
  },
  coverImage: { 
    type: String, 
    default: '/coverImage/1.png' 
  },
  description: { 
    type: String, 
    required: [true, '故事简介必填'], 
    maxlength: [500, '故事简介不能超过500个字符'] 
  },
  rating: { 
    type: Number, 
    default: 0, 
    min: 0, 
    max: 5 
  },
  view: { 
    type: Number, 
    default: 0, 
    min: 0 
  }
}, {
  timestamps: true,
  toJSON: { virtuals: true },
  toObject: { virtuals: true }
});

storySchema.virtual('sections', {
  ref: 'StorySection',
  localField: '_id',
  foreignField: 'storyId'
});</pre>
        
        <h3>2.2 StorySection（故事章节）模型（改进版）</h3>
        <pre>
const storySectionSchema = new mongoose.Schema({
  storyId: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'Story',
    required: [true, '故事ID必填'],
    index: true
  },
  // 新增：用于前端临时ID映射
  temporaryId: {
    type: String,
    index: true
  },
  type: {
    type: String,
    required: [true, '章节类型必填'],
    enum: ['text', 'choice', 'normal', 'ending'],  // 扩展支持前端使用的类型
    default: 'text'
  },
  order: {
    type: Number,
    required: [true, '章节顺序必填'],
    min: 1
  },
  title: {
    type: String,  // 新增：节点标题
    default: '未命名节点'
  },
  text: {
    type: String,
    required: [true, '章节文本必填']
  },
  // 新增：节点在画布上的位置信息
  visualPosition: {
    x: {
      type: Number,
      default: 0
    },
    y: {
      type: Number,
      default: 0
    }
  },
  choices: [{
    text: {
      type: String,
      required: [true, '选项文本必填']
    },
    // 新增：支持临时ID引用
    nextTemporaryId: {
      type: String
    },
    nextSectionId: {
      type: mongoose.Schema.Types.ObjectId,
      ref: 'StorySection',
      required: false
    }
  }],
  isEnd: {
    type: Boolean,
    default: false
  }
}, {
  timestamps: true
});</pre>
        
        <h2>3. API 接口</h2>
        
        <h3>3.1 故事基本操作</h3>
        
        <div class="endpoint">
            <h4><span class="method get">GET</span> /api/v1/stories</h4>
            <p><strong>功能：</strong>获取故事列表</p>
            <p><strong>查询参数：</strong></p>
            <ul>
                <li><code>page</code> - 页码，默认1</li>
                <li><code>limit</code> - 每页数量，默认9</li>
                <li><code>sort</code> - 排序方式（latest/popular/rating）</li>
                <li><code>category</code> - 分类名称</li>
                <li><code>search</code> - 搜索关键词</li>
            </ul>
            <p><strong>响应：</strong></p>
            <pre>{
  "success": true,
  "message": "获取故事列表成功",
  "data": {
    "stories": [
      {
        "id": "5f8a1b...",
        "title": "故事标题",
        "description": "故事简介",
        "category": { "id": "...", "name": "分类名" },
        "author": { "id": "...", "username": "作者名", "avatar": "头像URL" },
        "coverImage": "封面URL",
        "view": 100,
        "rating": 4.5,
        "createdAt": "2023-01-01T00:00:00Z"
      }
    ],
    "pagination": {
      "page": 1,
      "limit": 9,
      "total": 100,
      "pages": 12
    }
  }
}</pre>
        </div>
        
        <div class="endpoint">
            <h4><span class="method get">GET</span> /api/v1/stories/:storyId</h4>
            <p><strong>功能：</strong>获取故事详情（阅读模式）</p>
            <p><strong>查询参数：</strong></p>
            <ul>
                <li><code>includeAuthorWorks</code> - 是否包含作者其他作品，默认为true</li>
                <li><code>includeStatistics</code> - 是否包含统计信息（阅读时长、结局数量等），默认为true</li>
            </ul>
            <p><strong>响应：</strong></p>
            <pre>{
  "success": true,
  "message": "获取故事详情成功",
  "data": {
    "id": "5f8a1b...",
    "title": "迷失森林的秘密",
    "author": {
      "id": "...",
      "username": "林小雨",
      "avatar": "https://picsum.photos/id/1012/100",
      "otherWorks": [
        {
          "id": "...",
          "title": "月下的精灵",
          "coverImage": "https://picsum.photos/id/29/300/300",
          "rating": 4.6,
          "description": "一个关于人类与精灵友谊的故事..."
        },
        {
          "id": "...",
          "title": "时光之钥",
          "coverImage": "https://picsum.photos/id/96/300/300",
          "rating": 4.7,
          "description": "一把能够打开时间之门的神秘钥匙..."
        }
      ]
    },
    "category": { "id": "...", "name": "奇幻冒险" },
    "coverImage": "https://picsum.photos/id/119/1200/600",
    "description": "在一片神秘的森林中，主人公发现了通往另一个世界的入口...",
    "statistics": {
      "endingsCount": 8,
      "readingTime": "25分钟",
      "avgRating": 4.8,
      "favoritesCount": 128
    },
    "sections": [
      {
        "id": "5f8a1c...",
        "order": 1,
        "type": "text",
        "text": "暮色四合，你背着行囊站在一片陌生的森林边缘...",
        "choices": [],
        "isEnd": false
      },
      {
        "id": "5f8a1d...",
        "order": 2,
        "type": "choice",
        "text": "你继续往前走了大约十几分钟，眼前出现了一个岔路口...",
        "choices": [
          {
            "id": "choice-1",
            "text": "向左走，前往幽暗的树林",
            "description": "探索未知的水域，也许能找到离开森林的线索",
            "nextSectionId": "5f8a1e..."
          },
          {
            "id": "choice-2",
            "text": "向右走，前往木屋寻求帮助",
            "description": "也许木屋里的人能告诉你这是什么地方",
            "nextSectionId": "5f8a1f..."
          }
        ],
        "isEnd": false
      }
    ],
    "view": 1000,
    "rating": 4.8,
    "createdAt": "2023-10-15T00:00:00Z"
  }
}</pre>
        </div>
        
        <div class="endpoint">
            <h4><span class="method post">POST</span> /api/v1/stories</h4>
            <p><strong>功能：</strong>创建新故事</p>
            <p><strong>请求体：</strong></p>
            <pre>{
  "title": "新故事标题",
  "categoryId": "5f8a1a...",
  "description": "故事简介",
  "coverImage": "封面URL"  // 可选
}</pre>
            <p><strong>响应：</strong></p>
            <pre>{
  "success": true,
  "message": "创建故事成功",
  "data": {
    "id": "5f8a1b...",
    "title": "新故事标题"
  }
}</pre>
        </div>
        
        <h3>3.2 故事图谱操作（新增）</h3>
        
        <div class="endpoint">
            <h4><span class="method get">GET</span> /api/v1/stories/:storyId/graph</h4>
            <p><strong>功能：</strong>获取完整故事图谱（编辑模式）</p>
            <p><strong>说明：</strong>仅作者可访问，返回用于编辑的完整故事结构，包含所有节点位置信息和连接关系</p>
            <p><strong>响应：</strong></p>
            <pre>{
  "success": true,
  "data": {
    "nodes": [
      {
        "id": "5f8a1c...",
        "temporaryId": "123456",
        "title": "起始节点",
        "content": "故事开始...",
        "type": "normal",
        "position": { "x": 100, "y": 100 },
        "isEnd": false
      },
      {
        "id": "5f8a1d...",
        "temporaryId": "654321",
        "title": "分支节点",
        "content": "你选择了...",
        "type": "normal",
        "position": { "x": 200, "y": 200 },
        "isEnd": true
      }
    ],
    "connections": [
      {
        "from": "5f8a1c...",
        "to": "5f8a1d...",
        "description": "选择这条路径"
      }
    ]
  }
}</pre>
        </div>
        
        <div class="endpoint">
            <h4><span class="method put">PUT</span> /api/v1/stories/:storyId/graph</h4>
            <p><strong>功能：</strong>保存完整故事图谱</p>
            <p><strong>说明：</strong>仅作者可访问，保存完整的故事结构，包括节点位置和连接关系</p>
            <p><strong>请求体：</strong></p>
            <pre>{
  "nodes": [
    {
      "temporaryId": "123456",
      "title": "起始节点",
      "content": "故事开始...",
      "type": "normal",
      "position": { "x": 100, "y": 100 },
      "isEnd": false
    },
    {
      "temporaryId": "654321",
      "title": "分支节点",
      "content": "你选择了...",
      "type": "normal",
      "position": { "x": 200, "y": 200 },
      "isEnd": true
    }
  ],
  "connections": [
    {
      "from": "123456",  // 临时ID
      "to": "654321",    // 临时ID
      "description": "选择这条路径"
    }
  ],
  "metadata": {
    "estimatedReadingTime": 25, // 估计阅读时间（分钟）
    "endingsCount": 8,         // 结局数量
    "updateStatistics": true   // 是否更新统计信息
  }
}</pre>
            <p><strong>响应：</strong></p>
            <pre>{
  "success": true,
  "message": "故事图谱已保存",
  "data": {
    "updatedNodes": 2,
    "updatedConnections": 1,
    "mappings": {
      "123456": "5f8a1c...",
      "654321": "5f8a1d..."
    },
    "statistics": {
      "totalNodes": 2,
      "endingsCount": 1,
      "estimatedReadingTime": 5
    }
  }
}</pre>
        </div>
        
        <h3>3.3 章节操作（改进版）</h3>
        
        <div class="endpoint">
            <h4><span class="method get">GET</span> /api/v1/sections/:storyId</h4>
            <p><strong>功能：</strong>获取故事的所有章节</p>
            <p><strong>响应：</strong></p>
            <pre>{
  "success": true,
  "data": [
    {
      "id": "5f8a1c...",
      "temporaryId": "123456",
      "order": 1,
      "type": "text",
      "title": "第一章",
      "text": "章节内容",
      "visualPosition": { "x": 100, "y": 100 },
      "choices": [],
      "isEnd": false,
      "createdAt": "2023-01-01T00:00:00Z"
    }
  ]
}</pre>
        </div>
        
        <div class="endpoint">
            <h4><span class="method post">POST</span> /api/v1/sections/:storyId</h4>
            <p><strong>功能：</strong>创建单个章节</p>
            <p><strong>请求体：</strong></p>
            <pre>{
  "temporaryId": "123456",  // 前端生成的临时ID
  "title": "新章节",
  "type": "normal",
  "order": 1,
  "text": "章节内容",
  "visualPosition": { "x": 100, "y": 200 },
  "choices": [
    {
      "text": "选择A",
      "nextTemporaryId": "654321"  // 引用目标节点的临时ID
    }
  ],
  "isEnd": false
}</pre>
            <p><strong>响应：</strong></p>
            <pre>{
  "success": true,
  "message": "章节创建成功",
  "data": {
    "id": "5f8a1c...",
    "temporaryId": "123456",
    "title": "新章节"
  }
}</pre>
        </div>
        
        <div class="endpoint">
            <h4><span class="method post">POST</span> /api/v1/sections/:storyId/batch</h4>
            <p><strong>功能：</strong>批量创建章节（解决临时ID引用问题）</p>
            <p><strong>请求体：</strong></p>
            <pre>{
  "nodes": [
    {
      "temporaryId": "123456",
      "title": "节点1",
      "type": "normal",
      "text": "内容1",
      "visualPosition": { "x": 100, "y": 100 },
      "isEnd": false
    },
    {
      "temporaryId": "654321",
      "title": "节点2",
      "type": "normal",
      "text": "内容2",
      "visualPosition": { "x": 200, "y": 200 },
      "isEnd": true
    }
  ],
  "connections": [
    {
      "from": "123456",  // 临时ID
      "to": "654321",    // 临时ID
      "description": "前往节点2"
    }
  ]
}</pre>
            <p><strong>响应：</strong></p>
            <pre>{
  "success": true,
  "message": "批量创建章节成功",
  "data": {
    "createdNodes": [
      { "temporaryId": "123456", "id": "5f8a1c..." },
      { "temporaryId": "654321", "id": "5f8a1d..." }
    ],
    "mappings": {  // 临时ID到MongoDB ID的映射
      "123456": "5f8a1c...",
      "654321": "5f8a1d..."
    }
  }
}</pre>
        </div>
        
        <div class="endpoint">
            <h4><span class="method put">PUT</span> /api/v1/sections/:storyId/:sectionId</h4>
            <p><strong>功能：</strong>更新章节信息</p>
            <p><strong>请求体：</strong></p>
            <pre>{
  "title": "更新的标题",
  "text": "更新的内容",
  "visualPosition": { "x": 150, "y": 250 },
  "choices": [
    {
      "text": "更新的选项",
      "nextTemporaryId": "789012",
      "nextSectionId": "5f8a1e..."
    }
  ],
  "isEnd": false
}</pre>
            <p><strong>响应：</strong></p>
            <pre>{
  "success": true,
  "message": "章节更新成功",
  "data": {
    "id": "5f8a1c...",
    "title": "更新的标题"
  }
}</pre>
        </div>
        
        <div class="endpoint">
            <h4><span class="method put">PUT</span> /api/v1/sections/:storyId/connections</h4>
            <p><strong>功能：</strong>更新章节连接（解决临时ID映射）</p>
            <p><strong>请求体：</strong></p>
            <pre>{
  "mappings": {
    "123456": "5f8a1c...",
    "654321": "5f8a1d...",
    "789012": "5f8a1e..."
  }
}</pre>
            <p><strong>响应：</strong></p>
            <pre>{
  "success": true,
  "message": "节点连接已更新",
  "data": {
    "updatedCount": 3
  }
}</pre>
        </div>
        
        <div class="endpoint">
            <h4><span class="method delete">DELETE</span> /api/v1/sections/:storyId/:sectionId</h4>
            <p><strong>功能：</strong>删除章节</p>
            <p><strong>查询参数：</strong></p>
            <ul>
                <li><code>adjustOrder</code> - 是否调整后续章节顺序，默认为true</li>
            </ul>
            <p><strong>响应：</strong></p>
            <pre>{
  "success": true,
  "message": "章节已删除，后续章节顺序已重新调整"
}</pre>
        </div>
        
        <h2>4. 核心功能实现说明</h2>
        
        <h3>4.1 临时ID映射机制</h3>
        <div class="note">
            <p><strong>问题分析：</strong>前端使用临时ID创建节点和连接，而后端使用MongoDB ObjectId，导致节点间的引用关系无法在创建时建立。</p>
        </div>
        
        <h4>解决方案：</h4>
        <pre>// 后端批量保存节点的实现逻辑
async function processNodesWithTemporaryIds(storyId, nodes, connections) {
  // 1. 第一阶段：创建所有节点，保留临时ID
  const idMappings = {};
  
  for (const node of nodes) {
    const section = new StorySection({
      storyId,
      temporaryId: node.temporaryId,
      title: node.title,
      type: node.type,
      text: node.text,
      visualPosition: node.visualPosition,
      isEnd: node.isEnd || false,
      order: node.order || 0,
      choices: []  // 先不设置连接，后续更新
    });
    
    await section.save();
    idMappings[node.temporaryId] = section._id.toString();
  }
  
  // 2. 第二阶段：根据临时ID创建连接关系
  for (const connection of connections) {
    const fromSection = await StorySection.findOne({
      storyId,
      temporaryId: connection.from
    });
    
    if (fromSection) {
      fromSection.choices.push({
        text: connection.description,
        nextTemporaryId: connection.to,
        nextSectionId: idMappings[connection.to] || null
      });
      
      await fromSection.save();
    }
  }
  
  return idMappings;
}</pre>
        
        <h3>4.2 前端集成示例</h3>
        
        <h4>保存节点到后端：</h4>
        <pre>// 前端保存节点的改进实现
async function saveNodeToBackend() {
  try {
    const node = graphData.nodes[currentNodeId];
    if (!node) return;
    
    // 准备节点数据，包含临时ID和连接信息
    const sectionData = {
      storyId: currentStoryId,
      temporaryId: node.id,  // 使用前端临时ID
      title: node.title,
      type: node.type === 'choice' ? 'choice' : 'text',
      order: 1, // 可以根据需要调整
      text: node.content,
      visualPosition: node.position || { x: 0, y: 0 },
      choices: graphData.connections
        .filter(conn => conn.from === currentNodeId)
        .map(conn => ({
          text: conn.description,
          nextTemporaryId: conn.to,  // 使用目标节点的临时ID
          nextSectionId: null  // 后端会在批量保存时更新
        })),
      isEnd: node.type === 'ending'
    };
    
    // 如果是单个节点保存，使用创建接口
    const response = await fetch(`/api/v1/sections/${currentStoryId}`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(sectionData)
    });
    
    const result = await response.json();
    if (result.success) {
      // 记录临时ID到MongoDB ID的映射
      idMappings[currentNodeId] = result.data.id;
      showNotification('节点已保存', 'success');
    }
  } catch (error) {
    console.error('保存节点失败', error);
    showNotification('保存失败', 'error');
  }
}</pre>
        
        <h4>批量保存故事图谱：</h4>
        <pre>// 前端批量保存故事图谱
async function saveEntireStoryGraph() {
  try {
    // 准备图谱数据
    const graphData = {
      nodes: Object.values(currentGraphData.nodes).map(node => ({
        temporaryId: node.id,
        title: node.title,
        content: node.content,
        type: node.type,
        position: node.position || { x: 0, y: 0 },
        isEnd: node.type === 'ending'
      })),
      connections: currentGraphData.connections.map(conn => ({
        from: conn.from,
        to: conn.to,
        description: conn.description
      }))
    };
    
    const response = await fetch(`/api/v1/sections/${currentStoryId}/batch`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(graphData)
    });
    
    const result = await response.json();
    if (result.success) {
      // 更新本地ID映射
      Object.assign(idMappings, result.data.mappings);
      showNotification('整个故事图谱已保存', 'success');
    }
  } catch (error) {
    console.error('批量保存失败', error);
    showNotification('保存失败', 'error');
  }
}</pre>
        
        <h3>4.3 事务处理确保数据一致性</h3>
        <pre>// 使用MongoDB事务确保批量操作的数据一致性
async function saveStoryGraphWithTransaction(storyId, nodes, connections) {
  const session = await mongoose.startSession();
  session.startTransaction();
  
  try {
    // 1. 清除现有章节（可选，根据需求）
    // await StorySection.deleteMany({ storyId }).session(session);
    
    // 2. 创建节点
    const idMappings = {};
    for (const node of nodes) {
      const section = new StorySection({
        storyId,
        temporaryId: node.temporaryId,
        title: node.title,
        type: node.type,
        text: node.text,
        visualPosition: node.visualPosition,
        isEnd: node.isEnd || false,
        order: node.order || 0,
        choices: []
      });
      
      await section.save({ session });
      idMappings[node.temporaryId] = section._id.toString();
    }
    
    // 3. 创建连接
    for (const connection of connections) {
      const fromSection = await StorySection.findOne({
        storyId,
        temporaryId: connection.from
      }).session(session);
      
      if (fromSection) {
        fromSection.choices.push({
          text: connection.description,
          nextTemporaryId: connection.to,
          nextSectionId: idMappings[connection.to] || null
        });
        await fromSection.save({ session });
      }
    }
    
    // 4. 提交事务
    await session.commitTransaction();
    return { success: true, mappings: idMappings };
  } catch (error) {
    // 5. 出错时回滚
    await session.abortTransaction();
    throw error;
  } finally {
    session.endSession();
  }
}</pre>
        
        <h2>5. 前端与后端交互流程</h2>
        
        <h3>5.1 故事创建与编辑流程</h3>
        <div class="flow-diagram">
            <h4>故事创建流程：</h4>
            <ol>
                <li>前端创建故事基本信息（调用 <code>POST /api/v1/stories</code>）</li>
                <li>后端返回故事ID</li>
                <li>前端初始化故事图谱，创建起始节点（使用临时ID）</li>
                <li>作者编辑节点内容，创建分支</li>
                <li>分支创建时，引用目标节点的临时ID</li>
                <li>保存时，调用批量保存API <code>POST /api/v1/sections/:storyId/batch</code></li>
                <li>后端保存所有节点和连接，返回临时ID到MongoDB ID的映射</li>
                <li>前端更新本地映射，完成保存</li>
            </ol>
        </div>
        
        <div class="flow-diagram">
            <h4>故事编辑流程：</h4>
            <ol>
                <li>前端获取故事图谱数据（调用 <code>GET /api/v1/stories/:storyId/graph</code>）</li>
                <li>后端返回完整的节点和连接数据</li>
                <li>前端在画布上展示节点和连接</li>
                <li>作者添加、编辑、删除节点或连接</li>
                <li>保存时，调用图谱保存API <code>PUT /api/v1/stories/:storyId/graph</code></li>
                <li>后端更新所有节点和连接</li>
            </ol>
        </div>
        
        <h3>5.2 故事阅读流程</h3>
        <div class="flow-diagram">
            <h4>用户阅读故事：</h4>
            <ol>
                <li>用户选择一个故事，进入阅读页面</li>
                <li>前端获取故事详情（调用 <code>GET /api/v1/stories/:storyId</code>）</li>
                <li>后端返回故事信息、章节内容、统计数据和作者其他作品</li>
                <li>前端展示故事封面、信息和起始章节内容</li>
                <li>用户选择一个分支选项，通过URL参数传递选择（如 <code>story-context.html?id=1&sectionId=5f8a1d...</code>）</li>
                <li>前端获取指定章节内容（可选：调用 <code>GET /api/v1/sections/:sectionId</code> 获取单个章节）</li>
                <li>前端根据选择更新进度显示</li>
                <li>重复步骤5-7，直到到达结束节点</li>
            </ol>
        </div>
        
        <h3>5.3 用户交互功能</h3>
        <div class="flow-diagram">
            <h4>收藏功能：</h4>
            <ol>
                <li>用户点击收藏按钮</li>
                <li>前端检查用户登录状态</li>
                <li>如已登录，调用 <code>POST /api/v1/users/collections</code> 添加收藏</li>
                <li>或调用 <code>DELETE /api/v1/users/collections/:storyId</code> 取消收藏</li>
                <li>更新UI状态，显示收藏/取消收藏成功提示</li>
                <li>如未登录，引导用户登录</li>
            </ol>
            
            <h4>评分功能：</h4>
            <ol>
                <li>用户点击评分按钮</li>
                <li>前端显示评分选项</li>
                <li>用户选择评分星级</li>
                <li>前端调用 <code>POST /api/v1/stories/:storyId/rate</code> 提交评分</li>
                <li>更新UI显示最新评分</li>
            </ol>
        </div>
        
        <h2>6. 错误处理</h2>
        
        <h3>6.1 错误码定义</h3>
        <table>
            <thead>
                <tr>
                    <th>错误码</th>
                    <th>错误类型</th>
                    <th>描述</th>
                    <th>HTTP状态码</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td>10001</td>
                    <td>VALIDATION_ERROR</td>
                    <td>数据验证失败</td>
                    <td>400</td>
                </tr>
                <tr>
                    <td>10010</td>
                    <td>NOT_FOUND</td>
                    <td>故事或章节不存在</td>
                    <td>404</td>
                </tr>
                <tr>
                    <td>10011</td>
                    <td>PERMISSION_DENIED</td>
                    <td>没有权限操作</td>
                    <td>403</td>
                </tr>
                <tr>
                    <td>10012</td>
                    <td>NOT_AUTHENTICATED</td>
                    <td>需要登录</td>
                    <td>401</td>
                </tr>
                <tr>
                    <td>10015</td>
                    <td>MAPPING_ERROR</td>
                    <td>ID映射失败</td>
                    <td>400</td>
                </tr>
                <tr>
                    <td>10016</td>
                    <td>CIRCULAR_REFERENCE</td>
                    <td>检测到循环引用</td>
                    <td>400</td>
                </tr>
                <tr>
                    <td>10017</td>
                    <td>GRAPH_INTEGRITY_ERROR</td>
                    <td>图谱完整性错误</td>
                    <td>400</td>
                </tr>
                <tr>
                    <td>10018</td>
                    <td>COLLECTION_EXISTS</td>
                    <td>已收藏此故事</td>
                    <td>400</td>
                </tr>
                <tr>
                    <td>10019</td>
                    <td>RATING_OUT_OF_RANGE</td>
                    <td>评分超出范围</td>
                    <td>400</td>
                </tr>
                <tr>
                    <td>10020</td>
                    <td>INTERNAL_ERROR</td>
                    <td>服务器内部错误</td>
                    <td>500</td>
                </tr>
            </tbody>
        </table>
        
        <h3>6.2 错误响应格式</h3>
        <pre>{
  "success": false,
  "message": "错误描述信息",
  "errorCode": 10001,
  "errors": [
    {
      "field": "title",
      "message": "故事标题不能为空"
    }
  ]
}</pre>
        
        <h2>7. 性能优化建议</h2>
        
        <h3>7.1 后端优化</h3>
        <ul>
            <li><strong>索引优化</strong>：为常用查询字段添加索引，特别是 <code>storyId</code>、<code>temporaryId</code> 和 <code>order</code></li>
            <li><strong>批量操作</strong>：使用批量API减少网络请求次数</li>
            <li><strong>缓存机制</strong>：
                <ul>
                    <li>使用Redis缓存热门故事数据</li>
                    <li>对故事图谱数据进行缓存，减少数据库查询</li>
                    <li>缓存用户收藏和评分状态</li>
                </ul>
            </li>
            <li><strong>分页加载</strong>：大量章节时使用分页加载</li>
            <li><strong>连接预加载</strong>：使用MongoDB的populate优化关联查询</li>
            <li><strong>数据压缩</strong>：传输大量数据时使用压缩</li>
            <li><strong>异步处理</strong>：使用异步队列处理统计信息更新等非实时操作</li>
        </ul>
        
        <h3>7.2 前端优化</h3>
        <ul>
            <li><strong>懒加载</strong>：只加载当前阅读章节和相邻章节，减少初始加载时间</li>
            <li><strong>图片优化</strong>：使用WebP格式，实现响应式图片加载</li>
            <li><strong>状态管理</strong>：使用本地存储保存阅读进度和用户选择</li>
            <li><strong>预加载</strong>：预测用户可能选择的下一个章节并预加载</li>
            <li><strong>组件缓存</strong>：复用UI组件，减少DOM操作</li>
            <li><strong>CDN加速</strong>：使用CDN分发静态资源和API响应</li>
        </ul>
        
        <h2>8. 安全考虑</h2>
        
        <div class="warning">
            <h4>注意事项：</h4>
            <ul>
                <li>所有修改操作必须验证用户权限和身份</li>
                <li>使用JWT认证保护API访问</li>
                <li>批量操作需要限制大小，防止恶意请求</li>
                <li>输入数据必须进行严格验证和清理，防止XSS攻击</li>
                <li>敏感信息（如用户详细信息）不要暴露在响应中</li>
                <li>实现请求频率限制，防止API滥用和DDoS攻击</li>
                <li>使用HTTPS加密传输数据</li>
                <li>实现CSRF保护机制</li>
                <li>定期清理临时ID映射数据，避免存储过多无用信息</li>
            </ul>
        </div>
        
        <h2>9. 总结</h2>
        
        <h2>9. 完整的前端与后端交互示例</h2>
        
        <h3>9.1 阅读模式前端实现示例</h3>
        <pre>// 故事阅读页面的主要功能实现
class StoryReader {
  constructor(storyId, sectionId = null) {
    this.storyId = storyId;
    this.currentSectionId = sectionId;
    this.storyData = null;
    this.readingProgress = [];
    this.init();
  }
  
  async init() {
    try {
      // 加载故事数据
      await this.loadStoryData();
      
      // 显示故事内容
      this.renderStory();
      
      // 检查并显示收藏状态
      this.checkCollectionStatus();
      
      // 绑定事件
      this.bindEvents();
      
    } catch (error) {
      console.error('初始化故事阅读器失败:', error);
      this.showErrorMessage('加载故事失败，请稍后重试');
    }
  }
  
  async loadStoryData() {
    const response = await fetch(`/api/v1/stories/${this.storyId}`);
    const result = await response.json();
    
    if (result.success) {
      this.storyData = result.data;
      
      // 如果没有指定章节，使用第一个章节
      if (!this.currentSectionId) {
        const firstSection = this.storyData.sections.find(s => s.order === 1);
        this.currentSectionId = firstSection ? firstSection.id : null;
      }
      
      // 保存阅读进度到本地存储
      this.saveReadingProgress();
    } else {
      throw new Error(result.message || '加载故事失败');
    }
  }
  
  renderStory() {
    // 渲染故事基本信息
    this.renderStoryInfo();
    
    // 渲染当前章节
    this.renderCurrentSection();
    
    // 渲染作者其他作品
    this.renderAuthorWorks();
  }
  
  renderCurrentSection() {
    const section = this.findSectionById(this.currentSectionId);
    if (!section) {
      this.showErrorMessage('章节不存在');
      return;
    }
    
    const contentElement = document.getElementById('story-content');
    const choicesElement = document.getElementById('story-choices');
    
    // 清空内容
    contentElement.innerHTML = '';
    choicesElement.innerHTML = '';
    
    // 添加章节文本
    const paragraphs = section.text.split('\n').filter(p => p.trim());
    paragraphs.forEach(text => {
      const p = document.createElement('p');
      p.textContent = text;
      p.className = 'mb-6';
      contentElement.appendChild(p);
    });
    
    // 添加选择分支
    if (section.choices && section.choices.length > 0) {
      section.choices.forEach(choice => {
        const choiceButton = document.createElement('button');
        choiceButton.className = 'w-full p-6 bg-slate-50 rounded-xl text-left hover:bg-primary/5 transition-colors border border-slate-100 hover:border-primary/30 mb-4';
        
        const choiceContent = document.createElement('a');
        choiceContent.href = `story-context.html?id=${this.storyId}&sectionId=${choice.nextSectionId}`;
        choiceContent.className = 'block w-full h-full';
        choiceContent.innerHTML = `
          <h4 class="font-bold text-lg mb-2">${choice.text}</h4>
          <p class="text-slate-600">${choice.description || ''}</p>
        `;
        
        choiceButton.appendChild(choiceContent);
        choicesElement.appendChild(choiceButton);
      });
    }
    
    // 更新进度显示
    this.updateProgressDisplay();
  }
  
  findSectionById(sectionId) {
    return this.storyData.sections.find(s => s.id === sectionId);
  }
  
  async checkCollectionStatus() {
    const authState = this.getAuthState();
    if (!authState) return;
    
    try {
      const response = await fetch('/api/v1/users/collections', {
        headers: { 'Authorization': `Bearer ${authState.token}` }
      });
      
      if (response.ok) {
        const result = await response.json();
        const isCollected = result.data.some(c => c.story._id === this.storyId);
        this.updateCollectionButton(isCollected);
      }
    } catch (error) {
      console.error('检查收藏状态失败:', error);
    }
  }
  
  bindEvents() {
    // 绑定收藏按钮事件
    const collectBtn = document.getElementById('collect-btn');
    if (collectBtn) {
      collectBtn.addEventListener('click', () => this.toggleCollection());
    }
    
    // 绑定评分按钮事件
    const ratingBtn = document.getElementById('rating-btn');
    if (ratingBtn) {
      ratingBtn.addEventListener('click', () => this.showRatingDialog());
    }
  }
  
  async toggleCollection() {
    const authState = this.getAuthState();
    if (!authState) {
      alert('请先登录后再收藏');
      window.location.href = 'login.html';
      return;
    }
    
    const collectIcon = document.getElementById('collect-icon');
    const isCollected = collectIcon.classList.contains('fa-heart');
    
    try {
      if (isCollected) {
        // 取消收藏
        await fetch(`/api/v1/users/collections/${this.storyId}`, {
          method: 'DELETE',
          headers: {
            'Authorization': `Bearer ${authState.token}`,
            'Content-Type': 'application/json'
          }
        });
        this.updateCollectionButton(false);
        this.showNotification('已取消收藏', 'info');
      } else {
        // 添加收藏
        await fetch('/api/v1/users/collections', {
          method: 'POST',
          headers: {
            'Authorization': `Bearer ${authState.token}`,
            'Content-Type': 'application/json'
          },
          body: JSON.stringify({ storyId: this.storyId })
        });
        this.updateCollectionButton(true);
        this.showNotification('收藏成功', 'success');
      }
    } catch (error) {
      console.error('收藏操作失败:', error);
      this.showNotification('操作失败，请稍后重试', 'error');
    }
  }
  
  // 其他辅助方法...
}

// 初始化故事阅读器
document.addEventListener('DOMContentLoaded', () => {
  const urlParams = new URLSearchParams(window.location.search);
  const storyId = urlParams.get('id');
  const sectionId = urlParams.get('sectionId');
  
  if (storyId) {
    new StoryReader(storyId, sectionId);
  }
});</pre>
        
        <h3>9.2 编辑模式前端实现示例（改进版）</h3>
        <pre>// 故事编辑器的改进实现
class StoryEditor {
  constructor(storyId) {
    this.storyId = storyId;
    this.graphData = {
      nodes: {},
      connections: []
    };
    this.currentNodeId = null;
    this.idMappings = {}; // 临时ID到MongoDB ID的映射
    this.init();
  }
  
  async init() {
    try {
      // 从后端加载图谱数据
      await this.loadGraphData();
      
      // 初始化UI
      this.initUI();
      
      // 绑定事件
      this.bindEvents();
      
    } catch (error) {
      console.error('初始化编辑器失败:', error);
      this.showNotification('加载失败', 'error');
    }
  }
  
  async loadGraphData() {
    const response = await fetch(`/api/v1/stories/${this.storyId}/graph`);
    const result = await response.json();
    
    if (result.success) {
      // 初始化图谱数据
      this.graphData = {
        nodes: {},
        connections: []
      };
      
      // 构建节点映射
      result.data.nodes.forEach(node => {
        this.graphData.nodes[node.id] = {
          id: node.id,
          title: node.title,
          content: node.content,
          type: node.type,
          position: node.position,
          isEnd: node.isEnd
        };
        
        // 更新ID映射
        if (node.temporaryId) {
          this.idMappings[node.temporaryId] = node.id;
        }
      });
      
      // 构建连接
      this.graphData.connections = result.data.connections;
      
    } else {
      throw new Error(result.message || '加载失败');
    }
  }
  
  // 添加新节点
  addNode(type = 'normal') {
    // 生成临时ID
    const temporaryId = this.generateTemporaryId();
    
    const node = {
      id: temporaryId,
      title: '未命名节点',
      content: '',
      type: type,
      position: { x: 100, y: 100 },
      isEnd: type === 'ending'
    };
    
    this.graphData.nodes[temporaryId] = node;
    this.renderNode(node);
    this.currentNodeId = temporaryId;
    
    return temporaryId;
  }
  
  // 添加连接
  addConnection(fromNodeId, toNodeId, description) {
    const connection = {
      from: fromNodeId,
      to: toNodeId,
      description: description || '选择此路径'
    };
    
    this.graphData.connections.push(connection);
    this.renderConnection(connection);
    
    return connection;
  }
  
  // 保存当前节点到后端
  async saveCurrentNode() {
    if (!this.currentNodeId) return;
    
    const node = this.graphData.nodes[this.currentNodeId];
    if (!node) return;
    
    try {
      // 准备节点数据，包含临时ID和连接信息
      const sectionData = {
        temporaryId: node.id,
        title: node.title,
        type: node.type,
        order: 0, // 后端会根据需要处理顺序
        text: node.content,
        visualPosition: node.position,
        choices: this.graphData.connections
          .filter(conn => conn.from === node.id)
          .map(conn => ({
            text: conn.description,
            nextTemporaryId: conn.to
          })),
        isEnd: node.isEnd
      };
      
      const response = await fetch(`/api/v1/sections/${this.storyId}`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(sectionData)
      });
      
      const result = await response.json();
      if (result.success) {
        // 更新映射
        this.idMappings[node.id] = result.data.id;
        
        // 如果是临时ID，更新节点ID
        if (!this.isMongoDBId(node.id)) {
          this.updateNodeId(node.id, result.data.id);
        }
        
        this.showNotification('节点已保存', 'success');
        return result.data.id;
      }
    } catch (error) {
      console.error('保存节点失败:', error);
      this.showNotification('保存失败', 'error');
    }
  }
  
  // 批量保存整个图谱
  async saveEntireGraph() {
    try {
      // 准备图谱数据
      const graphData = {
        nodes: Object.values(this.graphData.nodes).map(node => ({
          temporaryId: node.id,
          title: node.title,
          content: node.content,
          type: node.type,
          position: node.position,
          isEnd: node.isEnd
        })),
        connections: this.graphData.connections.map(conn => ({
          from: conn.from,
          to: conn.to,
          description: conn.description
        }))
      };
      
      const response = await fetch(`/api/v1/stories/${this.storyId}/graph`, {
        method: 'PUT',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(graphData)
      });
      
      const result = await response.json();
      if (result.success) {
        // 更新所有ID映射
        Object.assign(this.idMappings, result.data.mappings);
        
        // 更新节点ID
        for (const [temporaryId, realId] of Object.entries(result.data.mappings)) {
          if (this.graphData.nodes[temporaryId]) {
            this.updateNodeId(temporaryId, realId);
          }
        }
        
        this.showNotification('整个故事图谱已保存', 'success');
        return true;
      }
    } catch (error) {
      console.error('保存图谱失败:', error);
      this.showNotification('保存失败', 'error');
    }
    return false;
  }
  
  // 辅助方法：判断是否为MongoDB ID
  isMongoDBId(id) {
    // 简化的MongoDB ObjectId判断
    return /^[0-9a-fA-F]{24}$/.test(id);
  }
  
  // 辅助方法：生成临时ID
  generateTemporaryId() {
    return 'temp_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
  }
  
  // 辅助方法：更新节点ID
  updateNodeId(oldId, newId) {
    // 更新节点映射
    const node = this.graphData.nodes[oldId];
    if (node) {
      node.id = newId;
      this.graphData.nodes[newId] = node;
      delete this.graphData.nodes[oldId];
    }
    
    // 更新连接中的ID引用
    this.graphData.connections.forEach(conn => {
      if (conn.from === oldId) conn.from = newId;
      if (conn.to === oldId) conn.to = newId;
    });
    
    // 更新当前节点ID
    if (this.currentNodeId === oldId) {
      this.currentNodeId = newId;
    }
  }
  
  // 其他UI和事件处理方法...
}

// 初始化编辑器
document.addEventListener('DOMContentLoaded', () => {
  const urlParams = new URLSearchParams(window.location.search);
  const storyId = urlParams.get('id');
  
  if (storyId) {
    new StoryEditor(storyId);
  }
});</pre>
        
        <h2>10. 总结</h2>
        
        <p>本API设计通过引入临时ID映射机制、批量操作接口和完善的数据模型，解决了故事生成系统中的核心问题：</p>
        
        <div class="success">
            <ul>
                <li><strong>节点关系处理</strong>：通过临时ID映射解决了节点创建时的引用问题</li>
                <li><strong>批量操作支持</strong>：提供批量保存API，减少网络请求，提高性能</li>
                <li><strong>完整图谱管理</strong>：支持完整故事图谱的获取和保存</li>
                <li><strong>数据一致性保证</strong>：使用事务确保批量操作的数据一致性</li>
                <li><strong>前后端无缝集成</strong>：简化了前端与后端的数据交互流程</li>
                <li><strong>阅读体验优化</strong>：提供丰富的故事信息和用户交互功能</li>
                <li><strong>性能和安全保障</strong>：通过缓存、索引和安全措施确保系统高效安全运行</li>
            </ul>
        </div>
        
        <p>这些改进将显著提升故事生成系统的用户体验，使作者能够更加自由地创建复杂的交互式故事，同时保持数据的完整性和一致性。阅读者也能获得流畅的故事体验，并与故事进行互动。整个系统架构更加健壮、可扩展，能够支持更复杂的故事创作和阅读需求。</p>
    </div>
</body>
</html>