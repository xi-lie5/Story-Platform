# 开发文档

## 1. 开发流程概述

本文档定义了StoryForge平台的标准化开发流程，包括代码提交规范、分支管理策略、模块化设计原则、组件复用机制及规范，以及前后端协作模式和接口联调流程说明。

## 2. 代码提交规范

### 2.1 提交信息格式
使用统一的提交信息格式，便于自动化工具处理和团队成员理解。

**格式：**
```
<type>(<scope>): <subject>

<body>

<footer>
```

**说明：**
- **type**：提交类型，必填
- **scope**：提交影响的范围，可选
- **subject**：提交的简短描述，必填
- **body**：提交的详细说明，可选
- **footer**：提交的脚注，可选

### 2.2 提交类型
| 类型 | 描述 | 示例 |
|------|------|------|
| feat | 新功能 | feat(auth): 添加用户注册功能 |
| fix | 修复bug | fix(nodes): 修复节点拖拽功能 |
| docs | 文档修改 | docs: 更新API文档 |
| style | 代码格式修改 | style: 优化代码缩进 |
| refactor | 代码重构 | refactor(stories): 重构故事管理模块 |
| perf | 性能优化 | perf: 优化数据库查询 |
| test | 测试代码 | test: 添加单元测试 |
| build | 构建配置修改 | build: 更新依赖版本 |
| ci | CI配置修改 | ci: 调整CI流程 |
| chore | 其他修改 | chore: 清理临时文件 |

### 2.3 提交示例
```
feat(storyNodes): 添加批量保存节点功能

- 实现了节点批量保存API
- 优化了节点数据结构
- 添加了数据验证

BREAKING CHANGE: 节点数据格式发生变化
```

### 2.4 提交要求
- 每个提交只包含一个功能或修复
- 提交信息使用中文
- 提交信息简洁明了，不超过50个字符
- 提交前确保代码通过测试
- 提交前确保代码符合代码规范

## 3. 分支管理策略

### 3.1 分支类型
| 分支类型 | 描述 | 命名规则 | 生命周期 |
|----------|------|----------|----------|
| main | 主分支，用于发布生产版本 | main | 永久 |
| develop | 开发分支，用于集成功能 | develop | 永久 |
| feature | 功能分支，用于开发新功能 | feature/功能名称 | 临时 |
| hotfix | 热修复分支，用于修复生产bug | hotfix/修复内容 | 临时 |
| release | 发布分支，用于准备发布 | release/版本号 | 临时 |

### 3.2 分支管理流程

#### 3.2.1 功能开发流程
1. 从develop分支创建feature分支
2. 在feature分支上进行开发
3. 开发完成后，提交Pull Request到develop分支
4. 代码审查通过后，合并到develop分支
5. 删除feature分支

#### 3.2.2 发布流程
1. 从develop分支创建release分支
2. 在release分支上进行发布准备
3. 准备完成后，提交Pull Request到main分支
4. 代码审查通过后，合并到main分支
5. 从main分支创建标签，用于发布
6. 从main分支合并到develop分支
7. 删除release分支

#### 3.2.3 热修复流程
1. 从main分支创建hotfix分支
2. 在hotfix分支上进行修复
3. 修复完成后，提交Pull Request到main分支
4. 代码审查通过后，合并到main分支
5. 从main分支创建标签，用于发布
6. 从main分支合并到develop分支
7. 删除hotfix分支

### 3.3 分支命名规范
- 使用小写字母
- 使用连字符分隔单词
- 功能分支：`feature/功能名称`，如 `feature/auth-register`
- 热修复分支：`hotfix/修复内容`，如 `hotfix/fix-login-error`
- 发布分支：`release/版本号`，如 `release/1.0.0`

## 4. 模块化设计原则

### 4.1 模块化设计目标
- 提高代码复用性
- 降低代码耦合度
- 提高代码可维护性
- 便于团队协作

### 4.2 模块化设计原则
- **单一职责原则**：每个模块只负责一个功能
- **开放封闭原则**：模块对扩展开放，对修改封闭
- **依赖倒置原则**：依赖于抽象，不依赖于具体实现
- **接口隔离原则**：使用多个小接口，而不是一个大接口
- **迪米特法则**：模块只与直接依赖的模块通信

### 4.3 前端模块化
- 按功能模块组织代码
- 使用ES6+模块化语法
- 封装通用组件
- 统一API调用

### 4.4 后端模块化
- 按功能模块划分路由
- 使用MVC架构
- 封装通用中间件
- 分离业务逻辑和数据访问

## 5. 组件复用机制及规范

### 5.1 组件分类
| 组件类型 | 描述 | 示例 |
|----------|------|------|
| 基础组件 | 通用UI组件 | 按钮、输入框、卡片 |
| 业务组件 | 业务相关组件 | 导航栏、故事卡片、节点编辑器 |
| 功能组件 | 具有特定功能的组件 | AuthUI、API调用封装 |

### 5.2 组件设计原则
- **可复用性**：组件应能在不同场景下复用
- **可配置性**：组件应支持灵活配置
- **可扩展性**：组件应易于扩展
- **独立性**：组件应独立工作，不依赖外部环境

### 5.3 组件命名规范
- 使用PascalCase命名组件
- 组件名称应清晰描述组件功能
- 基础组件名称前加Base前缀，如BaseButton
- 业务组件名称前加业务模块前缀，如StoryCard

### 5.4 组件使用规范
- 统一引入组件
- 组件属性命名一致
- 组件事件命名使用on前缀，如onClick
- 组件文档化，说明组件的用途、属性、事件和示例

## 6. 前后端协作模式

### 6.1 协作流程
1. **需求分析**：前后端共同参与需求分析
2. **API设计**：前后端共同设计API接口
3. **开发阶段**：前后端并行开发
4. **接口联调**：前后端进行接口联调
5. **测试阶段**：前后端共同测试
6. **发布阶段**：前后端共同发布

### 6.2 API设计规范
- 使用RESTful API设计
- 统一API响应格式
- 明确API版本
- 详细的API文档

### 6.3 接口联调流程
1. 后端提供API文档
2. 前端根据API文档编写API调用代码
3. 后端部署测试环境
4. 前端连接测试环境进行联调
5. 发现问题，及时沟通解决
6. 联调完成，进行集成测试

### 6.4 沟通机制
- 每日站会，同步开发进度
- 定期评审，检查代码质量
- 使用项目管理工具，跟踪任务进度
- 建立技术交流群，及时沟通问题

## 7. 开发环境配置

### 7.1 前端开发环境
- **Node.js**：推荐版本 18.x
- **npm**：推荐版本 9.x
- **浏览器**：Chrome 90+，Firefox 88+，Safari 14+，Edge 90+
- **开发工具**：VS Code，Chrome DevTools

### 7.2 后端开发环境
- **Node.js**：推荐版本 18.x
- **npm**：推荐版本 9.x
- **MongoDB**：推荐版本 8.x
- **开发工具**：VS Code，Postman

### 7.3 环境变量配置
- 开发环境：.env.development
- 测试环境：.env.test
- 生产环境：.env.production

### 7.4 开发工具配置
- 使用Prettier进行代码格式化
- 使用ESLint进行代码检查
- 配置Git钩子，提交前检查代码

## 8. 代码规范

### 8.1 HTML规范
- 使用语义化标签
- 保持代码缩进一致
- 添加必要的注释
- 避免内联样式
- 使用UTF-8编码

### 8.2 CSS规范
- 使用Tailwind CSS类名
- 遵循移动优先原则
- 避免使用ID选择器
- 保持样式模块化
- 使用CSS变量定义颜色、字体等

### 8.3 JavaScript规范
- 使用ES6+语法
- 遵循模块化设计
- 添加必要的注释
- 处理异步错误
- 使用const和let代替var
- 函数名使用camelCase
- 类名使用PascalCase
- 常量名使用UPPER_CASE

### 8.4 后端代码规范
- 遵循MVC架构
- 每个路由文件负责一个功能模块
- 中间件按功能分类
- 模型定义清晰的数据结构
- API响应使用统一格式

## 9. 测试流程

### 9.1 测试类型
| 测试类型 | 描述 | 责任方 |
|----------|------|--------|
| 单元测试 | 测试独立的函数或组件 | 开发人员 |
| 集成测试 | 测试模块间的集成 | 开发人员 |
| 端到端测试 | 测试完整的用户流程 | QA人员 |
| 性能测试 | 测试系统性能 | QA人员 |
| 安全测试 | 测试系统安全性 | 安全团队 |

### 9.2 测试框架
| 测试类型 | 框架 | 配置文件 |
|----------|------|----------|
| 单元测试 | Jest | jest.config.js |
| 端到端测试 | Cypress | cypress.config.js |
| API测试 | Postman | - |

### 9.3 测试覆盖率
- 单元测试覆盖率：≥80%
- 集成测试覆盖率：≥70%
- 端到端测试覆盖率：≥60%

### 9.4 测试流程
1. 开发人员编写单元测试和集成测试
2. CI/CD工具自动运行测试
3. QA人员编写端到端测试
4. 测试通过后，部署到测试环境
5. 进行用户验收测试
6. 测试通过后，部署到生产环境

## 10. 部署流程

### 10.1 部署环境
- **开发环境**：本地开发环境
- **测试环境**：测试服务器
- **预发布环境**：预发布服务器
- **生产环境**：生产服务器

### 10.2 部署方式
- **前端**：使用CDN部署静态资源
- **后端**：使用PM2管理Node.js进程
- **数据库**：MongoDB Atlas

### 10.3 部署流程
1. 代码提交到Git仓库
2. CI/CD工具自动构建和测试
3. 构建成功后，部署到测试环境
4. 测试通过后，部署到预发布环境
5. 预发布测试通过后，部署到生产环境
6. 部署完成后，进行健康检查

### 10.4 回滚流程
1. 发现生产环境问题
2. 停止当前版本服务
3. 部署上一个稳定版本
4. 检查服务状态
5. 分析问题原因
6. 修复问题后，重新部署

## 11. 代码审查流程

### 11.1 代码审查目的
- 提高代码质量
- 发现潜在问题
- 知识共享
- 规范代码风格

### 11.2 代码审查标准
- 代码符合代码规范
- 代码结构清晰
- 代码逻辑正确
- 代码复用性高
- 代码易于维护
- 测试覆盖率足够

### 11.3 代码审查流程
1. 开发人员提交Pull Request
2. 代码审查人员进行代码审查
3. 发现问题，提出修改建议
4. 开发人员修改代码
5. 再次进行代码审查
6. 代码审查通过后，合并到目标分支

### 11.4 代码审查工具
- **GitHub**：Pull Request功能
- **GitLab**：Merge Request功能
- **SonarQube**：代码质量分析
- **ESLint**：代码规范检查

## 12. 文档管理

### 12.1 文档类型
- **需求文档**：详细的需求说明
- **设计文档**：系统设计说明
- **架构文档**：系统架构说明
- **技术文档**：技术栈说明
- **API文档**：API接口说明
- **开发文档**：开发流程说明
- **测试文档**：测试用例说明

### 12.2 文档维护
- 文档与代码同步更新
- 文档使用Markdown格式
- 文档存储在项目仓库中
- 定期审查文档，确保文档准确性

## 13. 版本管理

### 13.1 版本号格式
使用语义化版本号，格式为X.Y.Z
- **X**：主版本号，重大功能变更
- **Y**：次版本号，新功能添加
- **Z**：修订版本号，bug修复

### 13.2 版本发布流程
1. 确定版本内容
2. 更新版本号
3. 编写发布说明
4. 发布版本
5. 更新文档

### 13.3 版本发布说明
- 版本号
- 发布日期
- 新增功能
- 修复的bug
- 不兼容变更
- 升级说明

## 14. 安全开发规范

### 14.1 前端安全
- 防止XSS攻击
- 防止CSRF攻击
- 安全的API调用
- 敏感数据加密
- 安全的存储方式

### 14.2 后端安全
- 防止SQL注入
- 防止命令注入
- 安全的认证授权
- 安全的密码存储
- 安全的文件上传
- 安全的API设计

### 14.3 安全审计
- 定期进行安全审计
- 使用安全扫描工具
- 遵循安全最佳实践
- 及时更新依赖

## 15. 性能优化

### 15.1 前端性能优化
- 静态资源压缩
- 图片优化
- 懒加载
- 缓存策略
- 减少HTTP请求

### 15.2 后端性能优化
- 数据库索引优化
- 连接池管理
- 缓存机制
- 异步处理
- 负载均衡

### 15.3 性能监控
- 使用性能监控工具
- 定期分析性能数据
- 优化性能瓶颈

## 16. 故障处理

### 16.1 故障分类
| 故障等级 | 影响范围 | 响应时间 |
|----------|----------|----------|
| P0 | 系统完全不可用 | 立即响应 |
| P1 | 核心功能不可用 | 30分钟内响应 |
| P2 | 次要功能不可用 | 1小时内响应 |
| P3 | 轻微问题 | 24小时内响应 |

### 16.2 故障处理流程
1. 发现故障
2. 记录故障信息
3. 分析故障原因
4. 修复故障
5. 验证修复
6. 编写故障报告

### 16.3 故障报告
- 故障描述
- 故障影响范围
- 故障原因分析
- 修复方案
- 修复时间
- 预防措施

## 17. 团队协作规范

### 17.1 沟通规范
- 使用统一的沟通工具
- 及时回复消息
- 会议准时参加
- 尊重他人观点

### 17.2 任务管理
- 使用项目管理工具
- 任务分解清晰
- 任务状态及时更新
- 定期回顾任务进度

### 17.3 知识共享
- 定期分享技术知识
- 编写技术博客
- 组织技术培训
- 建立知识库

### 17.4 团队文化
- 开放、包容的团队文化
- 鼓励创新和尝试
- 重视团队成员的成长
- 庆祝团队成就

## 18. 附录

### 18.1 开发工具推荐
- **代码编辑器**：VS Code
- **终端工具**：Windows Terminal，iTerm2
- **版本控制**：Git
- **项目管理**：Jira，Trello
- **文档工具**：Confluence，Notion
- **API测试**：Postman，Insomnia

### 18.2 学习资源
- **HTML/CSS/JavaScript**：MDN Web Docs
- **Node.js**：Node.js官方文档
- **Express**：Express官方文档
- **MongoDB**：MongoDB官方文档
- **Jest**：Jest官方文档
- **Cypress**：Cypress官方文档

### 18.3 常见问题解决方案
- **依赖冲突**：使用npm ls命令检查依赖，使用npm dedupe命令解决冲突
- **端口占用**：使用lsof -i :端口号命令查找占用端口的进程，使用kill命令终止进程
- **数据库连接失败**：检查数据库连接字符串，检查数据库服务是否运行
- **API调用失败**：检查API地址，检查认证令牌，检查网络连接

### 18.4 联系方式
- **技术支持**：tech-support@storyforge.example.com
- **团队沟通**：slack.storyforge.example.com
- **项目管理**：jira.storyforge.example.com