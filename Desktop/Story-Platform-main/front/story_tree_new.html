<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>故事节点图谱 - StoryForge</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <link href="https://cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css" rel="stylesheet">
  <script>
    tailwind.config = {
      theme: {
        extend: {
          colors: {
            primary: '#6366f1',
            secondary: '#ec4899',
          },
        },
      },
      // 禁用生产环境警告
      future: {
        disableDeprecationWarnings: true,
      }
    }
  </script>
  <style>
    .tree-node {
      transition: all 0.3s ease;
      cursor: pointer;
      user-select: none;
      border-radius: 8px;
      position: relative;
      overflow: hidden;
      min-height: 100px;
      backdrop-filter: blur(10px);
    }
    .tree-node::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      width: 4px;
      height: 100%;
      background-color: var(--node-border-color, #6366f1);
      transition: all 0.3s ease;
    }
    .tree-node:hover {
      transform: translateY(-2px) scale(1.02);
      box-shadow: 0 12px 35px rgba(0,0,0,0.2);
    }
    .tree-node:hover::before {
      width: 8px;
    }
    .tree-node.selected-node {
      box-shadow: 0 0 0 4px rgba(99, 102, 241, 0.5), 0 6px 20px rgba(99, 102, 241, 0.3);
      animation: pulse 2s ease-in-out infinite;
      transform: scale(1.05);
      z-index: 50;
    }
    .tree-node.dragging {
      opacity: 0.8;
      transform: scale(1.08);
      z-index: 100;
      pointer-events: none;
    }
    .tree-node:not(.selected-node):active {
      transform: translateY(0) scale(0.98);
    }
    @keyframes pulse {
      0%, 100% {
        box-shadow: 0 0 0 4px rgba(99, 102, 241, 0.5), 0 4px 12px rgba(99, 102, 241, 0.3);
      }
      50% {
        box-shadow: 0 0 0 6px rgba(99, 102, 241, 0.4), 0 6px 20px rgba(99, 102, 241, 0.2);
      }
    }
    .tree-line {
      stroke: #cbd5e1;
      stroke-width: 2;
      fill: none;
      transition: stroke 0.3s ease, stroke-width 0.3s ease, opacity 0.3s ease;
      marker-end: url(#arrowhead);
      opacity: 0.8;
    }
    .tree-line:hover {
      stroke: #6366f1;
      stroke-width: 4;
      opacity: 1;
    }
    .tree-line.animated {
      stroke-dasharray: 5, 5;
      animation: dash 15s linear infinite;
      stroke: #8b5cf6;
    }
    /* 选中节点时，与它相关的连接线高亮 */
    .selected-node ~ svg .tree-line {
      opacity: 0.4;
    }
    /* 连接线的箭头标记 */
    #arrowhead {
      transition: fill 0.3s ease;
    }
    .tree-line:hover #arrowhead {
      fill: #6366f1;
    }
    @keyframes dash {
      to {
        stroke-dashoffset: -100;
      }
    }
    
    /* 节点类型特定样式 */
    .node-choice {
      --node-border-color: #f59e0b;
      background: linear-gradient(135deg, #fef3c7 0%, #fde68a 100%);
      border: 2px solid #f59e0b;
      color: #92400e;
    }
    .node-choice::before {
      content: '\f0a9'; /* Font Awesome 箭头图标 */
      font-family: 'FontAwesome';
      position: absolute;
      top: 10px;
      right: 10px;
      font-size: 12px;
      opacity: 0.5;
      pointer-events: none;
    }
    .node-ending {
      --node-border-color: #22c55e;
      background: linear-gradient(135deg, #dcfce7 0%, #bbf7d0 100%);
      border: 2px solid #22c55e;
      color: #166534;
    }
    .node-ending::before {
      content: '\f00c'; /* Font Awesome 对勾图标 */
      font-family: 'FontAwesome';
      position: absolute;
      top: 10px;
      right: 10px;
      font-size: 12px;
      opacity: 0.5;
      pointer-events: none;
    }
    .node-normal {
      --node-border-color: #3b82f6;
      background: linear-gradient(135deg, #eff6ff 0%, #dbeafe 100%);
      border: 2px solid #3b82f6;
      color: #1e40af;
    }
    .node-normal::before {
      content: '\f02d'; /* Font Awesome 书签图标 */
      font-family: 'FontAwesome';
      position: absolute;
      top: 10px;
      right: 10px;
      font-size: 12px;
      opacity: 0.5;
      pointer-events: none;
    }
    /* 增强节点内容展示 */
    .tree-node h4 {
      font-weight: 600;
      line-height: 1.4;
      margin-bottom: 6px;
    }
    .tree-node p {
      line-height: 1.4;
      opacity: 0.8;
    }
    /* 节点悬停时显示完整内容 */
    .tree-node:hover p {
      opacity: 1;
      display: block;
      display: -webkit-box;
      -webkit-line-clamp: 4;
      -webkit-box-orient: vertical;
      overflow: hidden;
    }
    .context-menu {
      position: fixed;
      background: white;
      border-radius: 10px;
      box-shadow: 0 6px 24px rgba(0,0,0,0.15), 0 0 0 1px rgba(0,0,0,0.05);
      padding: 6px 0;
      z-index: 1000;
      display: none;
      min-width: 190px;
      backdrop-filter: blur(10px);
      border: 1px solid rgba(255,255,255,0.18);
    }
    .context-menu-item {
      padding: 10px 20px;
      cursor: pointer;
      transition: all 0.2s ease;
      font-size: 14px;
      color: #374151;
      position: relative;
    }
    .context-menu-item:hover {
      background: linear-gradient(135deg, #f8fafc 0%, #e2e8f0 100%);
      color: #1e293b;
    }
    .context-menu-item:hover::before {
      content: '';
      position: absolute;
      left: 0;
      top: 50%;
      transform: translateY(-50%);
      width: 3px;
      height: 70%;
      background: #6366f1;
      border-radius: 0 3px 3px 0;
    }
    .context-menu-item i {
      width: 16px;
      text-align: center;
    }
    .choice-label {
      background: #fbbf24;
      color: white;
      font-size: 12px;
      padding: 2px 8px;
      border-radius: 12px;
      margin: 2px;
      display: inline-block;
    }
    .tree-canvas {
      background-image: 
        linear-gradient(rgba(0, 0, 0, 0.03) 1px, transparent 1px),
        linear-gradient(90deg, rgba(0,0,0,0.03) 1px, transparent 1px);
      background-size: 20px 20px;
      cursor: grab;
    }
    .tree-canvas.dragging {
      cursor: grabbing;
    }
    .selected-node {
      box-shadow: 0 0 0 4px rgba(59, 130, 246, 0.5);
    }
    .line-clamp-2 {
      display: -webkit-box;
      -webkit-line-clamp: 2;
      -webkit-box-orient: vertical;
      overflow: hidden;
    }
    .navbar-modern {
      background: rgba(255,255,255,0.98);
      backdrop-filter: blur(10px);
      border-bottom: 1px solid rgba(0,0,0,0.08);
      box-shadow: 0 1px 3px rgba(0,0,0,0.05);
    }
  </style>
</head>
<body class="bg-gradient-to-br from-slate-50 to-slate-100 min-h-screen">
  <!-- 导航栏 -->
  <header class="navbar-modern fixed top-0 left-0 right-0 z-50">
    <div class="container mx-auto px-4 py-3 flex items-center justify-between">
      <div class="flex items-center space-x-2">
        <div class="w-10 h-10 bg-gradient-to-br from-primary to-secondary rounded-xl flex items-center justify-center shadow-lg">
          <i class="fa fa-book text-white text-xl"></i>
        </div>
        <h1 class="text-xl font-bold bg-gradient-to-r from-primary to-secondary bg-clip-text text-transparent">StoryForge</h1>
      </div>
      
      <nav class="hidden md:flex items-center space-x-8">
        <a href="index.html" class="font-medium text-gray-600 hover:text-primary transition-colors">首页</a>
        <a href="explore.html" class="font-medium text-gray-600 hover:text-primary transition-colors">探索故事</a>
        <a href="create.html" class="font-medium text-gray-600 hover:text-primary transition-colors">创建故事</a>
        <a href="my_stories.html" class="font-medium text-gray-600 hover:text-primary transition-colors">我的作品</a>
        <a href="favorites.html" class="font-medium text-gray-600 hover:text-primary transition-colors">我的收藏</a>
        <a href="profile.html" class="font-medium text-gray-600 hover:text-primary transition-colors">个人中心</a>
        <a href="about.html" class="font-medium text-gray-600 hover:text-primary transition-colors">关于</a>
      </nav>
      
      <div class="flex items-center space-x-4 md:hidden">
        <button id="mobile-menu-button" class="p-2 rounded-lg hover:bg-slate-100 transition-colors">
          <i class="fa fa-bars text-slate-600 text-xl"></i>
        </button>
      </div>
      
      <div class="flex items-center space-x-4" id="auth-area-desktop"></div>
    </div>
  </header>

  <!-- 主要内容区 -->
  <section class="pt-20 pb-20 px-4">
    <div class="container mx-auto max-w-7xl">
      <!-- 标题与操作区 -->
      <div class="flex flex-col md:flex-row justify-between items-start md:items-center mb-6 gap-4">
        <div>
          <h2 class="text-2xl font-bold mb-2 text-gray-900">故事节点图谱</h2>
          <p class="text-gray-500">构建您的互动故事世界</p>
        </div>
        <div class="flex gap-3">
          <button id="create-root-node" class="px-4 py-2 bg-primary text-white rounded-lg hover:bg-primary/90 transition-colors flex items-center">
            <i class="fa fa-plus mr-2"></i> 创建故事开始
          </button>
          <button id="auto-layout" class="px-4 py-2 bg-white border border-gray-200 rounded-lg hover:bg-gray-50 transition-colors flex items-center">
            <i class="fa fa-magic mr-2"></i> 自动布局
          </button>
          <button id="save-graph" class="px-4 py-2 bg-green-500 text-white rounded-lg hover:bg-green-600 transition-colors flex items-center">
            <i class="fa fa-save mr-2"></i> 保存图谱
          </button>
          <button id="zoom-in" class="px-3 py-2 bg-white border border-gray-200 rounded-lg hover:bg-gray-50 transition-colors">
            <i class="fa fa-search-plus"></i>
          </button>
          <button id="zoom-out" class="px-3 py-2 bg-white border border-gray-200 rounded-lg hover:bg-gray-50 transition-colors">
            <i class="fa fa-search-minus"></i>
          </button>
          <button id="zoom-reset" class="px-3 py-2 bg-white border border-gray-200 rounded-lg hover:bg-gray-50 transition-colors">
            <i class="fa fa-compress"></i>
          </button>
        </div>
      </div>

      <!-- 故事信息 -->
      <div class="bg-white rounded-xl shadow-lg p-4 mb-6">
        <div class="flex flex-col md:flex-row justify-between items-start md:items-center gap-4">
          <div class="flex items-center space-x-4">
            <div>
              <h3 class="font-bold text-lg text-gray-900" id="current-story-title">加载中...</h3>
              <p class="text-sm text-gray-500">
                <span id="nodes-count">0</span> 个节点 · 
                <span id="tree-depth">0</span> 层深度
              </p>
            </div>
          </div>
          <div class="flex flex-col md:flex-row gap-4 w-full md:w-auto">
            <div class="relative w-full md:w-64">
              <input 
                type="text" 
                id="node-search-input" 
                class="w-full px-4 py-2 pr-10 border border-gray-300 rounded-lg focus:ring-2 focus:ring-primary focus:border-primary transition-all"
                placeholder="搜索节点标题或内容..."
              >
              <button id="clear-search" class="absolute right-3 top-1/2 transform -translate-y-1/2 text-gray-400 hover:text-gray-600" style="display: none;">
                <i class="fa fa-times-circle"></i>
              </button>
            </div>
            <div class="flex gap-2">
              <button id="filter-all" class="px-3 py-1.5 bg-primary text-white rounded-lg text-sm hover:bg-primary/90 transition-colors">
                全部
              </button>
              <button id="filter-normal" class="px-3 py-1.5 bg-blue-100 text-blue-800 rounded-lg text-sm hover:bg-blue-200 transition-colors">
                章节
              </button>
              <button id="filter-choice" class="px-3 py-1.5 bg-amber-100 text-amber-800 rounded-lg text-sm hover:bg-amber-200 transition-colors">
                选择
              </button>
              <button id="filter-ending" class="px-3 py-1.5 bg-green-100 text-green-800 rounded-lg text-sm hover:bg-green-200 transition-colors">
                结局
              </button>
            </div>
            <div class="flex gap-2">
              <button id="toggle-complete" class="px-4 py-2 border border-gray-200 rounded-lg hover:bg-gray-50 transition-colors flex items-center">
                <i class="fa fa-check-circle mr-2"></i>
                <span id="complete-text">标记完成</span>
              </button>
            </div>
          </div>
        </div>
      </div>

      <!-- 故事走向输入区 -->
      <div class="bg-white rounded-xl shadow-lg p-6 mb-6">
        <h3 class="text-lg font-semibold mb-4 text-gray-900">
          <i class="fa fa-pencil mr-2 text-primary"></i>输入故事走向
        </h3>
        <div class="flex gap-3">
          <div class="flex-1">
            <input 
              type="text" 
              id="story-direction-input" 
              class="w-full px-4 py-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-primary focus:border-primary transition-all" 
              placeholder="输入故事的大致走向，例如：主角遇到了一个神秘的老人..."
            >
            <p class="text-xs text-gray-500 mt-2">
              <i class="fa fa-info-circle mr-1"></i>每次输入后会自动创建一个节点，您可以在节点图谱中查看和编辑
            </p>
          </div>
          <button 
            id="create-node-from-input" 
            class="px-6 py-3 bg-primary text-white rounded-lg hover:bg-primary/90 transition-colors flex items-center whitespace-nowrap"
          >
            <i class="fa fa-plus mr-2"></i>创建节点
          </button>
        </div>
      </div>

      <!-- 故事树画布 -->
      <div class="bg-white rounded-xl shadow-lg overflow-hidden" style="height: 600px;">
        <div id="tree-canvas" class="tree-canvas w-full h-full relative overflow-hidden">
          <!-- 操作提示按钮 (仅在非空状态显示) -->
          <button id="help-button" class="absolute top-4 right-4 z-10 bg-blue-500 text-white p-2 rounded-full shadow-lg hover:bg-blue-600 transition-colors" style="display: none;" onclick="toggleHelp()">
            <i class="fa fa-question"></i>
          </button>
          
          <!-- 操作提示面板 -->
          <div id="help-panel" class="absolute top-16 right-4 z-10 bg-white border border-gray-200 rounded-lg shadow-xl p-4 w-80" style="display: none;">
            <div class="flex items-center justify-between mb-3">
              <h4 class="font-semibold text-gray-900">操作指南</h4>
              <button onclick="toggleHelp()" class="text-gray-400 hover:text-gray-600">
                <i class="fa fa-times"></i>
              </button>
            </div>
            <div class="space-y-2 text-sm">
              <div class="flex items-start">
                <i class="fa fa-mouse-pointer text-blue-500 mt-0.5 mr-2 w-4"></i>
                <div>
                  <strong class="text-gray-900">右键点击节点</strong>
                  <p class="text-gray-600">编辑、添加子节点、删除等操作</p>
                </div>
              </div>
              <div class="flex items-start">
                <i class="fa fa-hand-paper text-green-500 mt-0.5 mr-2 w-4"></i>
                <div>
                  <strong class="text-gray-900">拖拽画布</strong>
                  <p class="text-gray-600">按住鼠标左键拖动空白区域</p>
                </div>
              </div>
              <div class="flex items-start">
                <i class="fa fa-search-plus text-purple-500 mt-0.5 mr-2 w-4"></i>
                <div>
                  <strong class="text-gray-900">滚轮缩放</strong>
                  <p class="text-gray-600">使用鼠标滚轮放大/缩小视图</p>
                </div>
              </div>
              <div class="flex items-start">
                <i class="fa fa-arrows-alt text-orange-500 mt-0.5 mr-2 w-4"></i>
                <div>
                  <strong class="text-gray-900">拖拽节点</strong>
                  <p class="text-gray-600">按住鼠标左键拖动节点调整位置</p>
                </div>
              </div>
            </div>
          </div>
          
          <!-- SVG 连接线层 -->
          <svg id="connection-layer" class="absolute top-0 left-0 w-full h-full pointer-events-none" style="z-index: 1;">
            <!-- 定义箭头标记 -->
            <defs>
              <marker id="arrowhead" markerWidth="10" markerHeight="10" refX="9" refY="3" orient="auto" markerUnits="strokeWidth">
                <path d="M0,0 L0,6 L9,3 z" fill="#cbd5e1" />
              </marker>
            </defs>
          </svg>
          
          <!-- 节点层 -->
          <div id="nodes-layer" class="absolute top-0 left-0 w-full h-full" style="z-index: 2; transform-origin: 0 0;">
            <!-- 空状态 -->
            <div id="empty-state" class="flex flex-col items-center justify-center h-full">
              <i class="fa fa-sitemap text-6xl text-gray-300 mb-4"></i>
              <h3 class="text-xl font-semibold text-gray-600 mb-2">开始创建您的故事</h3>
              <p class="text-gray-500 mb-4">点击'创建故事开始'按钮来创建第一个节点</p>
              
              <button id="empty-create-root" class="px-6 py-3 bg-primary text-white rounded-lg hover:bg-primary/90 transition-colors flex items-center mb-6">
                <i class="fa fa-plus mr-2"></i> 创建故事开始
              </button>
              
              <!-- 操作提示 -->
              <div class="bg-blue-50 border border-blue-200 rounded-lg p-4 max-w-md">
                <div class="flex items-start">
                  <i class="fa fa-info-circle text-blue-500 mt-1 mr-3"></i>
                  <div>
                    <h4 class="font-semibold text-blue-900 mb-2">操作提示</h4>
                    <ul class="text-sm text-blue-800 space-y-1">
                      <li><i class="fa fa-mouse-pointer mr-2"></i><strong>右键点击节点</strong>：编辑、添加子节点、删除等操作</li>
                      <li><i class="fa fa-hand-paper mr-2"></i><strong>拖拽画布</strong>：移动整个故事树视图</li>
                      <li><i class="fa fa-search-plus mr-2"></i><strong>滚轮缩放</strong>：放大/缩小视图</li>
                      <li><i class="fa fa-arrows-alt mr-2"></i><strong>拖拽节点</strong>：调整节点位置</li>
                    </ul>
                  </div>
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
  </section>

  <!-- 移动端菜单 -->
  <div class="md:hidden hidden bg-white/95 backdrop-blur-md border-t border-slate-200 fixed top-[60px] left-0 right-0 z-40" id="mobile-menu">
    <div class="container mx-auto px-4 py-4 space-y-3">
      <a href="index.html" class="block py-3 px-4 rounded-lg font-medium text-slate-600 hover:bg-slate-50 hover:text-primary">首页</a>
      <a href="explore.html" class="block py-3 px-4 rounded-lg font-medium text-slate-600 hover:bg-slate-50 hover:text-primary">探索故事</a>
      <a href="create.html" class="block py-3 px-4 rounded-lg font-medium text-slate-600 hover:bg-slate-50 hover:text-primary">创建故事</a>
      <a href="my_stories.html" class="block py-3 px-4 rounded-lg font-medium text-slate-600 hover:bg-slate-50 hover:text-primary">我的作品</a>
      <a href="favorites.html" class="block py-3 px-4 rounded-lg font-medium text-slate-600 hover:bg-slate-50 hover:text-primary">我的收藏</a>
      <a href="profile.html" class="block py-3 px-4 rounded-lg font-medium text-slate-600 hover:bg-slate-50 hover:text-primary">个人中心</a>
      <a href="about.html" class="block py-3 px-4 rounded-lg font-medium text-slate-600 hover:bg-slate-50 hover:text-primary">关于</a>
      <div class="flex flex-col space-y-3 pt-3 border-t border-slate-200">
        <div id="auth-area-mobile">
          <!-- AuthUI会动态渲染移动端登录状态或用户信息 -->
        </div>
      </div>
    </div>
  </div>

  <!-- 右键菜单 -->
  <div id="context-menu" class="context-menu">
    <div class="context-menu-item" data-action="edit">
      <i class="fa fa-edit mr-2"></i> 编辑节点
    </div>
    <div class="context-menu-item" data-action="add-child">
      <i class="fa fa-plus mr-2"></i> 添加子节点
    </div>
    <div class="border-t border-gray-200 my-2"></div>
    <div class="context-menu-item" data-action="delete">
      <i class="fa fa-trash mr-2 text-red-500"></i> 删除节点
    </div>
  </div>

  <script src="assets/js/auth.js"></script>
  <script src="assets/js/api-config.js"></script>
  <script>  // 全局变量
    let currentStoryId = null;
    let graphData = {
      nodes: {},
      connections: []
    };
    let selectedNodeId = null;
    let zoomLevel = 1;
    let isDragging = false;
    let dragStartPos = { x: 0, y: 0 };
    let canvasOffset = { x: 0, y: 0 };
    let isNodeDragging = false;
    let draggedNodeId = null;
    let currentFilter = 'all';
    let currentSearchQuery = '';

    // 初始化
    document.addEventListener('DOMContentLoaded', function() {
      // 初始化AuthUI
      AuthUI.init({
        desktopArea: 'auth-area-desktop',
        mobileArea: 'auth-area-mobile'
      });
      
      initializePage();
      bindEvents();
      loadStoryData();
    });

    // 初始化页面
    function initializePage() {
      // 从URL获取故事ID
      const params = new URLSearchParams(window.location.search);
      currentStoryId = params.get('story') || 'default';
      
      // 设置画布事件
      const canvas = document.getElementById('tree-canvas');
      canvas.addEventListener('mousedown', handleCanvasMouseDown);
      canvas.addEventListener('mousemove', handleCanvasMouseMove);
      canvas.addEventListener('mouseup', handleCanvasMouseUp);
      canvas.addEventListener('mouseleave', handleCanvasMouseUp);
      canvas.addEventListener('wheel', handleCanvasWheel);
      
      // 设置移动端菜单事件
      const mobileMenuButton = document.getElementById('mobile-menu-button');
      const mobileMenu = document.getElementById('mobile-menu');
      
      if (mobileMenuButton && mobileMenu) {
        mobileMenuButton.addEventListener('click', function() {
          mobileMenu.classList.toggle('hidden');
        });
      }
      
      // 点击页面其他区域关闭移动端菜单
      if (mobileMenuButton && mobileMenu) {
        document.addEventListener('click', function(e) {
          if (!mobileMenuButton.contains(e.target) && !mobileMenu.contains(e.target)) {
            mobileMenu.classList.add('hidden');
          }
        });
      }
    }

    // 绑定事件
    function bindEvents() {
      // 创建根节点
      document.getElementById('create-root-node').addEventListener('click', createRootNode);
      document.getElementById('empty-create-root').addEventListener('click', createRootNode);
      
      // 从输入框创建节点
      document.getElementById('create-node-from-input').addEventListener('click', createNodeFromInput);
      
      // 输入框回车键创建节点
      document.getElementById('story-direction-input').addEventListener('keypress', function(e) {
        if (e.key === 'Enter') {
          e.preventDefault();
          createNodeFromInput();
        }
      });
      
      // 自动布局
      document.getElementById('auto-layout').addEventListener('click', autoLayout);
      
      // 手动保存
      document.getElementById('save-graph').addEventListener('click', manualSaveToBackend);
      
      // 缩放控制
      document.getElementById('zoom-in').addEventListener('click', () => zoom(1.2));
      document.getElementById('zoom-out').addEventListener('click', () => zoom(0.8));
      document.getElementById('zoom-reset').addEventListener('click', resetZoom);
      
      // 完成状态切换
      document.getElementById('toggle-complete').addEventListener('click', toggleComplete);
      
      // 右键菜单
      document.addEventListener('contextmenu', handleContextMenu);
      document.addEventListener('click', hideContextMenu);
      
      // 右键菜单项点击
      document.querySelectorAll('.context-menu-item').forEach(item => {
        item.addEventListener('click', handleContextMenuAction);
      });
      
      // 节点类型筛选
      document.getElementById('filter-all').addEventListener('click', () => setNodeFilter('all'));
      document.getElementById('filter-normal').addEventListener('click', () => setNodeFilter('normal'));
      document.getElementById('filter-choice').addEventListener('click', () => setNodeFilter('choice'));
      document.getElementById('filter-ending').addEventListener('click', () => setNodeFilter('ending'));
      
      // 节点搜索
      const searchInput = document.getElementById('node-search-input');
      const clearSearchBtn = document.getElementById('clear-search');
      
      searchInput.addEventListener('keyup', handleNodeSearch);
      clearSearchBtn.addEventListener('click', clearNodeSearch);
    }
    
    // 设置节点筛选
    function setNodeFilter(filterType) {
      currentFilter = filterType;
      
      // 更新按钮样式
      document.getElementById('filter-all').className = 'px-3 py-1.5 rounded-lg text-sm hover:bg-primary/90 transition-colors ' + (filterType === 'all' ? 'bg-primary text-white' : 'bg-gray-100 text-gray-700');
      document.getElementById('filter-normal').className = 'px-3 py-1.5 rounded-lg text-sm hover:bg-blue-200 transition-colors ' + (filterType === 'normal' ? 'bg-blue-100 text-blue-800' : 'bg-gray-100 text-gray-700');
      document.getElementById('filter-choice').className = 'px-3 py-1.5 rounded-lg text-sm hover:bg-amber-200 transition-colors ' + (filterType === 'choice' ? 'bg-amber-100 text-amber-800' : 'bg-gray-100 text-gray-700');
      document.getElementById('filter-ending').className = 'px-3 py-1.5 rounded-lg text-sm hover:bg-green-200 transition-colors ' + (filterType === 'ending' ? 'bg-green-100 text-green-800' : 'bg-gray-100 text-gray-700');
      
      // 重新渲染树
      renderTree();
    }
    
    // 处理节点搜索
    function handleNodeSearch(e) {
      currentSearchQuery = e.target.value.trim().toLowerCase();
      const clearSearchBtn = document.getElementById('clear-search');
      
      // 显示/隐藏清空按钮
      if (currentSearchQuery) {
        clearSearchBtn.style.display = 'block';
      } else {
        clearSearchBtn.style.display = 'none';
      }
      
      renderTree();
    }
    
    // 清空节点搜索
    function clearNodeSearch() {
      const searchInput = document.getElementById('node-search-input');
      const clearSearchBtn = document.getElementById('clear-search');
      
      searchInput.value = '';
      currentSearchQuery = '';
      clearSearchBtn.style.display = 'none';
      
      renderTree();
    }

    // 加载故事数据
    async function loadStoryData() {
      try {
        // 如果有故事ID，优先从后端加载
        if (currentStoryId !== 'default') {
          await loadFromBackend();
          // 如果后端加载成功，使用后端数据；否则使用本地数据
          if (Object.keys(graphData.nodes).length === 0) {
            const savedData = localStorage.getItem('storyGraphData');
            if (savedData) {
              graphData = JSON.parse(savedData);
            }
          }
        } else {
          // 从本地存储获取数据
          const savedData = localStorage.getItem('storyGraphData');
          if (savedData) {
            graphData = JSON.parse(savedData);
          }
        }
        
        // 加载故事信息
        await loadStoryInfo();
        
        // 渲染树状图
        renderTree();
        updateStoryInfo();
      } catch (error) {
        console.error('加载故事数据失败:', error);
        showNotification('加载故事数据失败', 'error');
      }
    }

    // 从后端加载数据
    async function loadFromBackend() {
      try {
        const token = localStorage.getItem('token') || sessionStorage.getItem('token');
        if (!token || currentStoryId === 'default') return;
        
        // 使用新的节点API加载数据
        const response = await fetch(API_CONFIG.NODES.getStoryNodes(currentStoryId), {
          headers: API_CONFIG.getAuthHeaders()
        });
        
        if (response.ok) {
          const result = await response.json();
          if (result.success && result.data && result.data.length > 0) {
            // 转换后端数据为前端格式
            convertBackendData(result.data);
            
            // 加载故事信息
            await loadStoryInfo();
          }
        }
      } catch (error) {
        console.error('从后端加载数据失败:', error);
      }
    }

    // 加载故事信息
    async function loadStoryInfo() {
      try {
        console.log('加载故事信息 - currentStoryId:', currentStoryId);
        const token = localStorage.getItem('token') || sessionStorage.getItem('token');
        console.log('加载故事信息 - token:', token);
        
        const storyTitleElement = document.getElementById('current-story-title');
        
        if (currentStoryId === 'default') {
          storyTitleElement.textContent = '默认故事';
          showNotification('当前为默认故事模式', 'info');
          return;
        }
        
        if (!token) {
          storyTitleElement.textContent = '请先登录';
          showNotification('请先登录以加载故事信息', 'error');
          return;
        }
        
        storyTitleElement.textContent = '加载中...';
        const response = await fetch(API_CONFIG.STORIES.getStory(currentStoryId), {
          headers: API_CONFIG.getAuthHeaders()
        });
        
        if (response.ok) {
          const result = await response.json();
          if (result.success && result.data) {
            const story = result.data;
            storyTitleElement.textContent = story.title || `故事 #${currentStoryId.slice(-6)}`;
          } else {
            const errorMsg = result.message || '故事信息获取失败';
            storyTitleElement.textContent = '加载失败';
            console.error('加载故事信息失败 - API返回失败:', result);
            showNotification(`加载故事信息失败: ${errorMsg}`, 'error');
          }
        } else {
          const responseText = await response.text();
          let errorMsg = `HTTP错误: ${response.status}`;
          try {
            const errorData = JSON.parse(responseText);
            errorMsg = errorData.message || errorMsg;
          } catch (parseError) {
            // 响应不是JSON格式
          }
          storyTitleElement.textContent = '加载失败';
          console.error('加载故事信息失败 - HTTP错误:', response.status, responseText);
          showNotification(`加载故事信息失败: ${errorMsg}`, 'error');
        }
      } catch (error) {
        console.error('加载故事信息失败:', error);
        document.getElementById('current-story-title').textContent = '加载失败';
        showNotification(`加载故事信息失败: ${error.message}`, 'error');
      }
    }

    // 转换后端数据格式
    function convertBackendData(nodes) {
      graphData = {
        nodes: {},
        connections: []
      };
      
      nodes.forEach(node => {
        const nodeId = node._id || node.id;
        graphData.nodes[nodeId] = {
          id: nodeId,
          title: node.title || '未命名节点',
          content: node.content || '',
          type: node.type || 'normal',
          position: node.position || { 
            x: Math.random() * 400 + 200, 
            y: Math.random() * 300 + 100 
          },
          depth: node.depth || 0,
          order: node.order || 0
        };
        
        // 添加连接关系 - 统一处理choices数组
        if (node.choices && node.choices.length > 0) {
          node.choices.forEach(choice => {
            const targetId = choice.targetNodeId?._id || choice.targetNodeId;
            if (targetId) {
              graphData.connections.push({
                from: nodeId,
                to: targetId.toString(),
                description: choice.text || '继续'
              });
            }
          });
        }
      });
    }

    // 从输入框创建节点
    async function createNodeFromInput() {
      console.log('开始创建节点...');
      const input = document.getElementById('story-direction-input');
      const direction = input.value.trim();
      
      if (!direction) {
        showNotification('请输入故事走向', 'error');
        input.focus();
        return;
      }
      
      // 检查是否有根节点
      const nodeIds = Object.keys(graphData.nodes);
      console.log('当前节点数量:', nodeIds.length);
      
      if (nodeIds.length === 0) {
        // 如果没有节点，先创建根节点
        console.log('没有根节点，创建根节点...');
        await createRootNode();
        // 重新获取节点列表
        const updatedNodeIds = Object.keys(graphData.nodes);
        console.log('创建根节点后节点数量:', updatedNodeIds.length);
        
        if (updatedNodeIds.length === 0) {
          // 如果根节点创建失败，停止执行
          console.log('根节点创建失败，停止执行');
          return;
        }
      }
      
      // 确定父节点（如果有选中的节点，使用选中的节点；否则使用最后一个节点）
      let parentNodeId = selectedNodeId;
      console.log('选中的节点ID:', parentNodeId);
      
      if (!parentNodeId) {
        // 找到最后一个节点作为父节点
        const nodes = Object.values(graphData.nodes);
        if (nodes.length > 0) {
          parentNodeId = nodes[nodes.length - 1].id;
          console.log('使用最后一个节点作为父节点:', parentNodeId);
        }
      }
      
      try {
        const token = localStorage.getItem('token') || sessionStorage.getItem('token');
        if (!token) {
          showNotification('请先登录', 'error');
          return;
        }
        
        // 创建节点数据
        const newNode = {
          title: direction.length > 20 ? direction.substring(0, 20) + '...' : direction,
          content: direction,
          type: 'normal',
          position: { 
            x: parentNodeId && graphData.nodes[parentNodeId] 
              ? graphData.nodes[parentNodeId].position.x + (Math.random() - 0.5) * 200
              : Math.random() * 400 + 200, 
            y: parentNodeId && graphData.nodes[parentNodeId]
              ? graphData.nodes[parentNodeId].position.y + 150
              : Math.random() * 300 + 100
          }
        };
        
        // 显示创建中提示
        showNotification('正在创建节点...', 'info');
        
        // 如果有父节点，通过API创建子节点
        if (parentNodeId && currentStoryId !== 'default') {
          try {
            const response = await API_CONFIG.post(API_CONFIG.NODES.createNode(currentStoryId), {
              parentId: parentNodeId,
              title: newNode.title,
              content: newNode.content,
              type: newNode.type
            });
            
            if (response.success) {
              const savedNode = response.data;
              newNode.id = savedNode._id || savedNode.id;
              newNode.position = savedNode.position || newNode.position;
              
              // 添加到图数据
              graphData.nodes[newNode.id] = newNode;
              
              // 如果有父节点，添加连接
              if (parentNodeId) {
                graphData.connections.push({
                  from: parentNodeId,
                  to: newNode.id,
                  description: '继续'
                });
              }
              
              // 保存数据
              saveGraphData();
              
              // 重新渲染
              renderTree();
              updateStoryInfo();
              
              // 清空输入框
              input.value = '';
              
              showNotification('节点创建成功', 'success');
              return;
            } else {
              showNotification(`节点创建失败: ${response.message}`, 'error');
              return;
            }
          } catch (error) {
            console.error('通过API创建节点失败:', error);
            showNotification(`节点创建失败: ${error.message}`, 'error');
            return;
          }
        }
        
        // 本地创建节点（仅在本地模式下）
        newNode.id = 'node-' + Date.now();
        graphData.nodes[newNode.id] = newNode;
        
        // 如果有父节点，添加连接
        if (parentNodeId) {
          graphData.connections.push({
            from: parentNodeId,
            to: newNode.id,
            description: '继续'
          });
        }
        
        // 保存数据
        saveGraphData();
        
        // 重新渲染
        renderTree();
        updateStoryInfo();
        
        // 清空输入框
        input.value = '';
        
        showNotification('节点创建成功（本地模式）', 'success');
      } catch (error) {
        console.error('创建节点失败:', error);
        showNotification(`创建节点失败: ${error.message}`, 'error');
      }
    }

    // 创建根节点
    async function createRootNode() {
      try {
        console.log('开始创建根节点...');
        const token = localStorage.getItem('token') || sessionStorage.getItem('token');
        console.log('创建根节点 - token:', token);

        // 检查是否已有根节点 - 修复：只检查根节点，不检查所有节点
        console.log('创建根节点 - 检查是否已有根节点');
        let hasRootNode = false;
        for (const nodeId in graphData.nodes) {
          const node = graphData.nodes[nodeId];
          // 根节点的特征：depth为0或没有父节点（在前端数据中体现为depth为0）
          if (node.depth === 0) {
            hasRootNode = true;
            break;
          }
        }
        
        console.log('创建根节点 - 已有根节点:', hasRootNode);
        if (hasRootNode) {
          showNotification('根节点已存在', 'info');
          return;
        }

        // 显示创建中提示
        showNotification('正在创建根节点...', 'info');

        // 无论是否有token或currentStoryId，都尝试创建根节点
        let isAPISuccess = false;
        
        // 如果有故事ID和token，尝试通过API创建根节点
        if (currentStoryId !== 'default' && token) {
          try {
            const createRootUrl = API_CONFIG.NODES.createRoot(currentStoryId);
            console.log('=== 通过API创建根节点开始 ===');
            console.log('URL:', createRootUrl);
            console.log('currentStoryId:', currentStoryId);
            console.log('token:', token);
            const requestData = {
              title: '故事开始',
              content: '这是故事的开始...'
            };
            console.log('请求数据:', JSON.stringify(requestData));
            
            // 直接使用fetch而不是API_CONFIG.post，以便更好地调试
            const response = await fetch(createRootUrl, {
              method: 'POST',
              headers: API_CONFIG.getAuthHeaders(),
              body: JSON.stringify(requestData)
            });
            
            console.log('响应状态:', response.status);
            console.log('响应头:', response.headers);
            const responseText = await response.text();
            console.log('响应内容:', responseText);
            
            let result;
            try {
              result = JSON.parse(responseText);
              console.log('解析后的响应:', result);
            } catch (parseError) {
              console.error('解析API响应失败:', parseError);
              console.error('错误堆栈:', parseError.stack);
              showNotification('API响应格式错误，将尝试本地创建', 'error');
              throw new Error('API响应解析失败');
            }
            
            if (response.ok) {
              if (result.success) {
                console.log('API返回成功，开始处理数据');
                const savedNode = result.data;
                console.log('API返回的节点数据:', savedNode);
                
                const rootNode = {
                  id: savedNode._id || savedNode.id,
                  title: savedNode.title || '故事开始',
                  content: savedNode.content || '这是故事的开始...',
                  type: savedNode.type || 'normal',
                  position: savedNode.position || { x: 400, y: 50 },
                  depth: savedNode.depth || 0,
                  order: savedNode.order || 0
                };
                
                // 添加到图数据
                graphData.nodes[rootNode.id] = rootNode;
                console.log('根节点已添加到图数据');
                
                // 保存数据
                saveGraphData();
                console.log('数据已保存到本地存储');
                
                // 重新渲染
                renderTree();
                console.log('树状图已重新渲染');
                updateStoryInfo();
                console.log('故事信息已更新');
                
                showNotification('根节点创建成功', 'success');
                isAPISuccess = true;
                console.log('=== 通过API创建根节点成功 ===');
                return;
              } else {
                const errorMsg = result.message || 'API创建根节点失败';
                console.error('API创建根节点失败 - result:', result);
                showNotification(`API创建根节点失败: ${errorMsg}，将尝试本地创建`, 'warning');
              }
            } else {
              const errorMsg = result.message || `HTTP错误: ${response.status}`;
              console.error('API创建根节点失败 - HTTP错误:', response.status, responseText);
              showNotification(`API创建根节点失败: ${errorMsg}，将尝试本地创建`, 'warning');
            }
          } catch (error) {
            console.error('通过API创建根节点失败:', error);
            console.error('错误堆栈:', error.stack);
            showNotification(`通过API创建根节点失败: ${error.message}，将尝试本地创建`, 'warning');
          }
          console.log('=== 通过API创建根节点结束 ===');
        } else if (currentStoryId === 'default') {
          console.log('当前为默认故事模式，将本地创建根节点');
          showNotification('当前为默认故事模式，将本地创建根节点', 'info');
        } else if (!token) {
          console.log('未登录，将本地创建根节点');
          showNotification('未登录，将本地创建根节点', 'info');
        }

        // 本地创建根节点（API请求失败或没有token或currentStoryId为default时）
        console.log('本地创建根节点...');
        const rootNode = {
          id: 'node-' + Date.now(),
          title: '故事开始',
          content: '这是故事的开始...',
          type: 'normal',
          position: { x: 400, y: 50 },
          depth: 0,
          order: 0
        };

        // 添加到图数据
        graphData.nodes[rootNode.id] = rootNode;

        // 保存数据
        saveGraphData();

        // 重新渲染
        renderTree();
        updateStoryInfo();
        
        showNotification('根节点创建成功（本地模式）', 'success');
      } catch (error) {
        console.error('创建根节点失败:', error);
        showNotification(`创建根节点失败: ${error.message}`, 'error');
      }
    }

    // 渲染树状图
    function renderTree() {
      const nodesLayer = document.getElementById('nodes-layer');
      const connectionLayer = document.getElementById('connection-layer');
      const emptyState = document.getElementById('empty-state');
      const helpButton = document.getElementById('help-button');
      
      // 清空现有内容
      nodesLayer.innerHTML = '';
      connectionLayer.innerHTML = '';
      
      // 筛选节点
      const filteredNodes = {};
      for (const nodeId in graphData.nodes) {
        const node = graphData.nodes[nodeId];
        // 先检查类型筛选
        const typeMatch = currentFilter === 'all' || node.type === currentFilter;
        // 再检查搜索查询
        const searchMatch = !currentSearchQuery || 
                           (node.title && node.title.toLowerCase().includes(currentSearchQuery)) ||
                           (node.content && node.content.toLowerCase().includes(currentSearchQuery));
        // 只有同时满足类型筛选和搜索查询的节点才会被显示
        if (typeMatch && searchMatch) {
          filteredNodes[nodeId] = node;
        }
      }
      
      const filteredNodeIds = Object.keys(filteredNodes);
      
      if (filteredNodeIds.length === 0) {
        nodesLayer.appendChild(emptyState.cloneNode(true));
        // 隐藏帮助按钮
        if (helpButton) helpButton.style.display = 'none';
        return;
      }
      
      // 显示帮助按钮
      if (helpButton) helpButton.style.display = 'block';
      
      // 筛选连接线 - 只显示两端节点都符合筛选条件的连接
      const filteredConnections = graphData.connections.filter(conn => {
        return filteredNodes[conn.from] && filteredNodes[conn.to];
      });
      
      // 绘制连接线
      filteredConnections.forEach(conn => {
        drawConnection(conn);
      });
      
      // 绘制节点
      filteredNodeIds.forEach(nodeId => {
        drawNode(filteredNodes[nodeId]);
      });
    }
    
    // 只重绘连接线
    function redrawConnections() {
      const connectionLayer = document.getElementById('connection-layer');
      // 清空现有连接线
      connectionLayer.innerHTML = '';
      
      // 筛选节点
      const filteredNodes = {};
      for (const nodeId in graphData.nodes) {
        const node = graphData.nodes[nodeId];
        // 先检查类型筛选
        const typeMatch = currentFilter === 'all' || node.type === currentFilter;
        // 再检查搜索查询
        const searchMatch = !currentSearchQuery || 
                           (node.title && node.title.toLowerCase().includes(currentSearchQuery)) ||
                           (node.content && node.content.toLowerCase().includes(currentSearchQuery));
        // 只有同时满足类型筛选和搜索查询的节点才会被显示
        if (typeMatch && searchMatch) {
          filteredNodes[nodeId] = node;
        }
      }
      
      // 筛选连接线 - 只显示两端节点都符合筛选条件的连接
      const filteredConnections = graphData.connections.filter(conn => {
        return filteredNodes[conn.from] && filteredNodes[conn.to];
      });
      
      // 重新绘制筛选后的连接线
      filteredConnections.forEach(conn => {
        drawConnection(conn);
      });
    }

    // 切换帮助面板显示
    function toggleHelp() {
      const helpPanel = document.getElementById('help-panel');
      if (helpPanel.style.display === 'none' || !helpPanel.style.display) {
        helpPanel.style.display = 'block';
      } else {
        helpPanel.style.display = 'none';
      }
    }

    // 绘制节点
    function drawNode(node) {
      const nodesLayer = document.getElementById('nodes-layer');
      const nodeEl = document.createElement('div');
      
      // 检查是否为根节点（depth为0或没有父节点）
      const isRootNode = node.depth === 0;
      
      // 根节点添加特殊样式
      const nodeClasses = isRootNode 
        ? `tree-node absolute bg-white rounded-lg shadow-lg p-4 select-none ${getNodeClass(node.type)} border-2 border-primary` 
        : `tree-node absolute bg-white rounded-lg shadow-lg p-4 select-none ${getNodeClass(node.type)}`;
      
      nodeEl.className = nodeClasses;
      nodeEl.id = `node-${node.id}`;
      nodeEl.style.left = `${node.position.x}px`;
      nodeEl.style.top = `${node.position.y}px`;
      nodeEl.style.width = '200px';
      
      // 根节点添加特殊标识
      const typeLabel = isRootNode ? '根节点' : getTypeLabel(node.type);
      const typeBadgeClass = isRootNode ? 'bg-primary text-white' : getTypeBadgeClass(node.type);
      
      nodeEl.innerHTML = `
        <div class="flex items-center justify-between mb-2">
          <span class="text-xs font-medium px-2 py-1 rounded-full ${typeBadgeClass}">
            ${typeLabel}
          </span>
          <button class="text-gray-400 hover:text-gray-600" onclick="event.stopPropagation()">
            <i class="fa fa-ellipsis-v text-xs"></i>
          </button>
        </div>
        <h4 class="font-medium text-sm mb-1 truncate text-gray-900">${node.title}</h4>
        <p class="text-xs text-gray-500 line-clamp-2">${node.content || '暂无内容'}</p>
      `;
      
      // 添加事件监听
      nodeEl.addEventListener('click', (e) => {
        e.stopPropagation();
        selectNode(node.id);
      });
      nodeEl.addEventListener('mousedown', (e) => startDragNode(e, node.id));
      nodeEl.addEventListener('contextmenu', (e) => showContextMenu(e, node.id));
      
      nodesLayer.appendChild(nodeEl);
    }

    // 绘制连接线
    function drawConnection(conn) {
      const svg = document.getElementById('connection-layer');
      const fromNode = graphData.nodes[conn.from];
      const toNode = graphData.nodes[conn.to];
      
      if (!fromNode || !toNode) return;
      
      const line = document.createElementNS('http://www.w3.org/2000/svg', 'path');
      const fromX = fromNode.position.x + 100;
      const fromY = fromNode.position.y + 60;
      const toX = toNode.position.x + 100;
      const toY = toNode.position.y;
      
      const midY = (fromY + toY) / 2;
      const d = `M ${fromX} ${fromY} C ${fromX} ${midY}, ${toX} ${midY}, ${toX} ${toY}`;
      
      line.setAttribute('d', d);
      line.setAttribute('class', 'tree-line animated');
      line.setAttribute('marker-end', 'url(#arrowhead)');
      
      svg.appendChild(line);
    }

    // 获取节点样式类
    function getNodeClass(type) {
      switch (type) {
        case 'choice': return 'node-choice';
        case 'ending': return 'node-ending';
        default: return 'node-normal';
      }
    }

    // 获取类型标签样式
    function getTypeBadgeClass(type) {
      switch (type) {
        case 'choice': return 'bg-amber-100 text-amber-800';
        case 'ending': return 'bg-green-100 text-green-800';
        default: return 'bg-blue-100 text-blue-800';
      }
    }

    // 获取类型标签文本
    function getTypeLabel(type) {
      switch (type) {
        case 'choice': return '选择';
        case 'ending': return '结局';
        default: return '章节';
      }
    }

    // 选择节点
    function selectNode(nodeId) {
      selectedNodeId = nodeId;
      
      // 更新选中状态
      document.querySelectorAll('.tree-node').forEach(el => {
        el.classList.remove('selected-node');
      });
      
      const selectedEl = document.getElementById(`node-${nodeId}`);
      if (selectedEl) {
        selectedEl.classList.add('selected-node');
      }
    }

    // 显示右键菜单
    function showContextMenu(e, nodeId) {
      e.preventDefault();
      e.stopPropagation();
      selectedNodeId = nodeId;
      
      const menu = document.getElementById('context-menu');
      menu.style.display = 'block';
      menu.style.left = `${e.clientX}px`;
      menu.style.top = `${e.clientY}px`;
    }

    // 处理右键菜单事件
    function handleContextMenu(e) {
      // 如果点击的是节点，显示节点菜单
      const nodeEl = e.target.closest('.tree-node');
      if (nodeEl) {
        const nodeId = nodeEl.id.replace('node-', '');
        showContextMenu(e, nodeId);
        return;
      }
      
      // 否则隐藏菜单
      hideContextMenu();
    }

    // 隐藏右键菜单
    function hideContextMenu() {
      document.getElementById('context-menu').style.display = 'none';
    }

    // 处理右键菜单操作
    function handleContextMenuAction(e) {
      const action = e.currentTarget.dataset.action;
      const nodeId = selectedNodeId;
      
      switch (action) {
        case 'edit':
          editNode(nodeId);
          break;
        case 'add-child':
          addChildNode(nodeId);
          break;
        case 'delete':
          deleteNode(nodeId);
          break;
      }
      
      hideContextMenu();
    }

    // 编辑节点
    function editNode(nodeId) {
      window.location.href = `story_editor_new.html?node=${nodeId}&story=${currentStoryId}&returnTo=story_tree_new.html`;
    }

    // 添加子节点
    async function addChildNode(parentId) {
      try {
        const token = localStorage.getItem('token') || sessionStorage.getItem('token');
        if (!token) {
          showNotification('请先登录', 'error');
          return;
        }
        
        const parentNode = graphData.nodes[parentId];
        if (!parentNode) {
          showNotification('父节点不存在', 'error');
          return;
        }
        
        // 创建节点数据
        const newNode = {
          title: '新章节',
          content: '',
          type: 'normal',
          position: { 
            x: parentNode.position.x + (Math.random() - 0.5) * 100,
            y: parentNode.position.y + 120
          }
        };
        
        // 显示创建中提示
        showNotification('正在创建子节点...', 'info');
        
        // 如果有故事ID，通过API创建子节点
        if (currentStoryId !== 'default') {
          try {
            const response = await API_CONFIG.post(API_CONFIG.NODES.createNode(currentStoryId), {
              parentId: parentId,
              title: newNode.title,
              content: newNode.content,
              type: newNode.type
            });
            
            if (response.success) {
              const savedNode = response.data;
              newNode.id = savedNode._id || savedNode.id;
              newNode.position = savedNode.position || newNode.position;
              
              // 添加到图数据
              graphData.nodes[newNode.id] = newNode;
              
              // 添加连接
              graphData.connections.push({
                from: parentId,
                to: newNode.id,
                description: '继续'
              });
              
              // 保存数据
              saveGraphData();
              
              // 重新渲染
              renderTree();
              updateStoryInfo();
              
              showNotification('子节点添加成功', 'success');
              return;
            } else {
              showNotification(`子节点添加失败: ${response.message}`, 'error');
              return;
            }
          } catch (error) {
            console.error('通过API创建子节点失败:', error);
            showNotification(`子节点添加失败: ${error.message}`, 'error');
            return;
          }
        }
        
        // 本地创建子节点（仅在本地模式下）
        newNode.id = 'node-' + Date.now();
        graphData.nodes[newNode.id] = newNode;
        
        // 添加连接
        graphData.connections.push({
          from: parentId,
          to: newNode.id,
          description: '继续'
        });
        
        // 保存数据
        saveGraphData();
        
        // 重新渲染
        renderTree();
        updateStoryInfo();
        
        showNotification('子节点添加成功（本地模式）', 'success');
      } catch (error) {
        console.error('添加子节点失败:', error);
        showNotification(`子节点添加失败: ${error.message}`, 'error');
      }
    }

    // 删除节点
    async function deleteNode(nodeId) {
      if (!confirm('确定要删除这个节点吗？此操作不可恢复。')) return;
      
      try {
        const token = localStorage.getItem('token') || sessionStorage.getItem('token');
        if (!token) {
          showNotification('请先登录', 'error');
          return;
        }
        
        // 调用后端API删除节点
        const response = await fetch(API_CONFIG.NODES.deleteNode(nodeId), {
          method: 'DELETE',
          headers: API_CONFIG.getAuthHeaders()
        });
        
        if (response.ok) {
          // 从本地删除节点
          delete graphData.nodes[nodeId];
          
          // 删除相关连接
          graphData.connections = graphData.connections.filter(
            conn => conn.from !== nodeId && conn.to !== nodeId
          );
          
          saveGraphData();
          renderTree();
          updateStoryInfo();
          
          showNotification('节点删除成功', 'success');
        } else {
          const error = await response.json();
          showNotification(`节点删除失败: ${error.message}`, 'error');
        }
      } catch (error) {
        console.error('删除节点失败:', error);
        showNotification(`节点删除失败: ${error.message}`, 'error');
      }
    }
    
    // 保存节点位置到后端
    async function saveNodePosition(nodeId) {
      if (!nodeId) return;
      
      try {
        const token = localStorage.getItem('token') || sessionStorage.getItem('token');
        if (!token) {
          return; // 未登录时不保存到后端
        }
        
        const node = graphData.nodes[nodeId];
        if (!node) return;
        
        // 调用后端API更新节点位置
        const response = await fetch(API_CONFIG.NODES.updateNode(nodeId), {
          method: 'PUT',
          headers: API_CONFIG.getAuthHeaders(),
          body: JSON.stringify({ position: node.position })
        });
        
        if (!response.ok) {
          const error = await response.json();
          console.error('保存节点位置失败:', error);
        }
      } catch (error) {
        console.error('保存节点位置失败:', error);
      }
    }

    // 自动布局
    function autoLayout() {
      const nodeIds = Object.keys(graphData.nodes);
      if (nodeIds.length === 0) return;
      
      // 简单的树状布局算法
      const levels = {};
      const visited = new Set();
      
      // 找到根节点
      const rootNodes = nodeIds.filter(id => 
        !graphData.connections.some(conn => conn.to === id)
      );
      
      // BFS分层
      const queue = rootNodes.map(id => ({ id, level: 0 }));
      
      while (queue.length > 0) {
        const { id, level } = queue.shift();
        
        if (visited.has(id)) continue;
        visited.add(id);
        
        if (!levels[level]) levels[level] = [];
        levels[level].push(id);
        
        // 找到子节点
        const children = graphData.connections
          .filter(conn => conn.from === id)
          .map(conn => conn.to);
        
        children.forEach(childId => {
          queue.push({ id: childId, level: level + 1 });
        });
      }
      
      // 重新定位节点
      Object.keys(levels).forEach(level => {
        const nodes = levels[level];
        const levelY = parseInt(level) * 150 + 50;
        const totalWidth = nodes.length * 250;
        const startX = (800 - totalWidth) / 2;
        
        nodes.forEach((nodeId, index) => {
          graphData.nodes[nodeId].position = {
            x: startX + index * 250,
            y: levelY
          };
        });
      });
      
      saveGraphData();
      renderTree();
      
      showNotification('自动布局完成', 'success');
    }

    // 缩放功能
    function zoom(factor) {
      zoomLevel *= factor;
      zoomLevel = Math.max(0.3, Math.min(3, zoomLevel));
      updateCanvasTransform();
    }

    function resetZoom() {
      zoomLevel = 1;
      canvasOffset = { x: 0, y: 0 };
      updateCanvasTransform();
    }

    // 更新画布变换
    function updateCanvasTransform() {
      const nodesLayer = document.getElementById('nodes-layer');
      const connectionLayer = document.getElementById('connection-layer');
      const transform = `translate(${canvasOffset.x}px, ${canvasOffset.y}px) scale(${zoomLevel})`;
      
      nodesLayer.style.transform = transform;
      nodesLayer.style.transformOrigin = '0 0';
      connectionLayer.style.transform = transform;
      connectionLayer.style.transformOrigin = '0 0';
    }

    // 画布拖拽功能
    function handleCanvasMouseDown(e) {
      if (e.target.id === 'tree-canvas' || e.target.id === 'nodes-layer' || e.target.id === 'connection-layer') {
        isDragging = true;
        dragStartPos = { x: e.clientX - canvasOffset.x, y: e.clientY - canvasOffset.y };
        document.getElementById('tree-canvas').classList.add('dragging');
        e.preventDefault();
      }
    }

    function handleCanvasMouseMove(e) {
      if (isDragging) {
        canvasOffset.x = e.clientX - dragStartPos.x;
        canvasOffset.y = e.clientY - dragStartPos.y;
        updateCanvasTransform();
      }
    }

    function handleCanvasMouseUp() {
      isDragging = false;
      document.getElementById('tree-canvas').classList.remove('dragging');
    }

    function handleCanvasWheel(e) {
      e.preventDefault();
      
      const canvas = document.getElementById('tree-canvas');
      const rect = canvas.getBoundingClientRect();
      
      // 获取鼠标在画布中的位置
      const mouseX = e.clientX - rect.left;
      const mouseY = e.clientY - rect.top;
      
      // 计算缩放前的世界坐标
      const worldX = (mouseX - canvasOffset.x) / zoomLevel;
      const worldY = (mouseY - canvasOffset.y) / zoomLevel;
      
      // 应用缩放
      const delta = e.deltaY > 0 ? 0.9 : 1.1;
      const newZoomLevel = Math.max(0.3, Math.min(3, zoomLevel * delta));
      
      // 计算缩放后的偏移量，使鼠标位置保持在相同的世界坐标
      canvasOffset.x = mouseX - worldX * newZoomLevel;
      canvasOffset.y = mouseY - worldY * newZoomLevel;
      zoomLevel = newZoomLevel;
      
      updateCanvasTransform();
    }

    // 节点拖拽功能
    function startDragNode(e, nodeId) {
      if (e.button !== 0) return; // 只响应左键
      
      e.stopPropagation();
      isNodeDragging = true;
      draggedNodeId = nodeId;
      
      const node = graphData.nodes[nodeId];
      const nodeEl = document.getElementById(`node-${nodeId}`);
      if (!nodeEl) return;
      
      const rect = nodeEl.getBoundingClientRect();
      const offsetX = e.clientX - rect.left;
      const offsetY = e.clientY - rect.top;
      
      function handleMouseMove(e) {
        if (!isNodeDragging) return;
        
        // 计算节点在画布中的新位置
        const canvasRect = document.getElementById('tree-canvas').getBoundingClientRect();
        const x = (e.clientX - canvasRect.left - canvasOffset.x - offsetX) / zoomLevel;
        const y = (e.clientY - canvasRect.top - canvasOffset.y - offsetY) / zoomLevel;
        
        // 更新节点位置
        node.position.x = x;
        node.position.y = y;
        
        // 更新节点DOM位置（避免频繁调用renderTree）
        nodeEl.style.left = `${x}px`;
        nodeEl.style.top = `${y}px`;
        
        // 只重绘连接线，不重绘所有节点
        redrawConnections();
      }
      
      function handleMouseUp() {
        isNodeDragging = false;
        const nodeId = draggedNodeId;
        draggedNodeId = null;
        
        // 清理事件监听
        document.removeEventListener('mousemove', handleMouseMove);
        document.removeEventListener('mouseup', handleMouseUp);
        
        // 最终重绘整个树，确保所有元素正确显示
        renderTree();
        
        // 保存位置到后端
        saveNodePosition(nodeId);
      }
      
      document.addEventListener('mousemove', handleMouseMove);
      document.addEventListener('mouseup', handleMouseUp);
    }

    // 更新故事信息
    function updateStoryInfo() {
      const nodeCount = Object.keys(graphData.nodes).length;
      const depth = calculateTreeDepth();
      
      document.getElementById('nodes-count').textContent = nodeCount;
      document.getElementById('tree-depth').textContent = depth;
      
      // 更新故事标题
      const titleEl = document.getElementById('current-story-title');
      if (titleEl && currentStoryId !== 'default') {
        titleEl.textContent = `故事 #${currentStoryId.slice(-6)}`;
      }
    }

    // 计算树深度
    function calculateTreeDepth() {
      const nodeIds = Object.keys(graphData.nodes);
      if (nodeIds.length === 0) return 0;
      
      const visited = new Set();
      let maxDepth = 0;
      
      function dfs(nodeId, depth) {
        if (visited.has(nodeId)) return;
        visited.add(nodeId);
        
        maxDepth = Math.max(maxDepth, depth);
        
        const children = graphData.connections
          .filter(conn => conn.from === nodeId)
          .map(conn => conn.to);
        
        children.forEach(childId => dfs(childId, depth + 1));
      }
      
      // 找到根节点并开始DFS
      const rootNodes = nodeIds.filter(id => 
        !graphData.connections.some(conn => conn.to === id)
      );
      
      rootNodes.forEach(rootId => dfs(rootId, 1));
      
      return maxDepth;
    }

    // 切换完成状态
    async function toggleComplete() {
      try {
        const token = localStorage.getItem('token') || sessionStorage.getItem('token');
        if (!token || currentStoryId === 'default') {
          showNotification('请先登录', 'error');
          return;
        }
        
        // 获取当前按钮状态
        const btn = document.getElementById('toggle-complete');
        const text = document.getElementById('complete-text');
        const isCurrentlyCompleted = text.textContent === '取消标记完成';
        
        // 使用API_CONFIG构建URL - 使用正确的端点
        const toggleUrl = API_CONFIG.buildUrl(`/stories/${currentStoryId}/complete`);
        const response = await fetch(toggleUrl, {
          method: 'PATCH',
          headers: API_CONFIG.getAuthHeaders(),
          body: JSON.stringify({ isCompleted: !isCurrentlyCompleted })
        });
        
        if (response.ok) {
          const result = await response.json();
          const isCompleted = result.data.isCompleted;
          
          if (isCompleted) {
            text.textContent = '取消标记完成';
            btn.classList.add('bg-green-50', 'border-green-200', 'text-green-700');
          } else {
            text.textContent = '标记完成';
            btn.classList.remove('bg-green-50', 'border-green-200', 'text-green-700');
          }
          
          showNotification(isCompleted ? '故事已标记为完成' : '已取消完成标记', 'success');
        } else {
          const errorData = await response.json();
          showNotification(`操作失败: ${errorData.message || '未知错误'}`, 'error');
        }
      } catch (error) {
        console.error('切换完成状态失败:', error);
        showNotification(`操作失败: ${error.message}`, 'error');
      }
    }

    // 保存数据到本地存储
    function saveGraphData() {
      localStorage.setItem('storyGraphData', JSON.stringify(graphData));
      console.log('数据已保存到本地存储');
    }
    
    // 手动保存到后端
    async function manualSaveToBackend() {
      try {
        const token = localStorage.getItem('token') || sessionStorage.getItem('token');
        if (!token || currentStoryId === 'default') {
          showNotification('请先登录', 'error');
          return;
        }
        
        // 检查token格式是否正确
        if (!token.includes('.')) {
          showNotification('无效的token格式', 'error');
          console.error('无效的token格式:', token);
          return;
        }
        
        showNotification('正在保存到服务器...', 'info');
        await syncToBackend();
        showNotification('保存成功', 'success');
      } catch (error) {
        console.error('手动保存失败:', error);
        showNotification(`保存失败: ${error.message}`, 'error');
      }
    }

    // 同步到后端
    async function syncToBackend() {
      try {
        const token = localStorage.getItem('token') || sessionStorage.getItem('token');
        if (!token || currentStoryId === 'default') return;
        
        // 将前端节点数据转换为后端格式
        const nodes = Object.values(graphData.nodes).map(node => ({
          tempId: node.id,
          title: node.title,
          content: node.content,
          type: node.type || 'normal',
          position: node.position || { x: 0, y: 0 },
          choices: graphData.connections
            .filter(conn => conn.from === node.id)
            .map(conn => ({
              id: `choice_${conn.from}_${conn.to}`,
              text: conn.description || '继续',
              tempTargetNodeId: conn.to
            }))
        }));
        
        // 使用批量保存API
        const response = await fetch(API_CONFIG.NODES.batchSave(currentStoryId), {
          method: 'POST',
          headers: API_CONFIG.getAuthHeaders(),
          body: JSON.stringify({ nodes })
        });
        
        if (response.ok) {
          const result = await response.json();
          if (result.success) {
            console.log('节点数据已保存到数据库:', result);
            // 更新节点ID映射
            if (result.data && result.data.length > 0) {
              result.data.forEach((savedNode, index) => {
                const originalNode = nodes[index];
                if (originalNode && graphData.nodes[originalNode.tempId]) {
                  const oldId = originalNode.tempId;
                  const newId = savedNode._id || savedNode.id;
                  if (oldId !== newId) {
                    graphData.nodes[newId] = graphData.nodes[oldId];
                    graphData.nodes[newId].id = newId;
                    delete graphData.nodes[oldId];
                    
                    // 更新连接中的ID
                    graphData.connections.forEach(conn => {
                      if (conn.from === oldId) conn.from = newId;
                      if (conn.to === oldId) conn.to = newId;
                    });
                  }
                }
              });
            }
            // 不显示通知，避免频繁提示
            // showNotification('数据已自动保存', 'success');
          }
        } else {
          const error = await response.json();
          console.error('保存失败:', error);
          // 不显示错误通知，避免干扰用户
          // showNotification('保存失败: ' + (error.message || '未知错误'), 'error');
        }
      } catch (error) {
        console.error('同步到后端失败:', error);
        // 不显示错误通知，避免干扰用户
        // showNotification('网络错误，保存失败', 'error');
      }
    }

    // 通知功能
    function showNotification(message, type = 'info') {
      const notification = document.createElement('div');
      notification.className = `fixed bottom-4 right-4 px-4 py-3 rounded-lg shadow-lg z-50 flex items-center transition-all duration-300 transform translate-y-10 opacity-0`;
      
      if (type === 'success') {
        notification.classList.add('bg-green-50', 'border', 'border-green-200', 'text-green-700');
        notification.innerHTML = `<i class="fa fa-check-circle mr-2"></i>${message}`;
      } else if (type === 'error') {
        notification.classList.add('bg-red-50', 'border', 'border-red-200', 'text-red-700');
        notification.innerHTML = `<i class="fa fa-exclamation-circle mr-2"></i>${message}`;
      } else {
        notification.classList.add('bg-blue-50', 'border', 'border-blue-200', 'text-blue-700');
        notification.innerHTML = `<i class="fa fa-info-circle mr-2"></i>${message}`;
      }
      
      document.body.appendChild(notification);
      setTimeout(() => notification.classList.remove('translate-y-10', 'opacity-0'), 10);
      setTimeout(() => {
        notification.classList.add('translate-y-10', 'opacity-0');
        setTimeout(() => notification.remove(), 300);
      }, 3000);
    }
  </script>
</body>
</html>