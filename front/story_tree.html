<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>故事节点图谱 - StoryForge</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet">
  <script>
    tailwind.config = {
      theme: {
        extend: {
          colors: {
            primary: '#6366f1',
            secondary: '#ec4899',
          }
        }
      }
    }
  </script>
  <style>
    /* 防止拖动时文本选择 */
    .node-grid, .node {
      -webkit-user-select: none;
      -moz-user-select: none;
      -ms-user-select: none;
      user-select: none;
    }
    
    .node {
      cursor: pointer;
      transition: all 0.3s ease;
      z-index: 10;
    }
    .node:hover {
      transform: scale(1.05);
      box-shadow: 0 10px 25px -5px rgba(99, 102, 241, 0.3);
    }
    .node.dragging {
      transform: scale(1.05);
      box-shadow: 0 10px 25px -5px rgba(99, 102, 241, 0.5);
      z-index: 100 !important;
    }
    .connection-line {
      position: absolute;
      background-color: #d1d5db;
      z-index: 0;
    }
    .node-grid {
      position: relative;
      min-height: 500px;
      background-color: #f9fafb;
      background-image: radial-gradient(rgba(0, 0, 0, 0.1) 1px, transparent 1px);
      background-size: 20px 20px;
      overflow: auto;
      cursor: grab;
    }
    .node-grid:active {
      cursor: grabbing;
    }
    .node-type-normal {
      border-color: #6366f1;
      background-color: white;
    }
    .node-type-choice {
      border-color: #f59e0b;
      background-color: #fffbeb;
    }
    .node-type-climax {
      border-color: #ec4899;
      background-color: #fdf2f8;
    }
    .node-type-ending {
      border-color: #10b981;
      background-color: #f0fdf4;
    }
  </style>
</head>
<body class="bg-gradient-to-br from-slate-50 to-slate-100 min-h-screen">
  <!-- 导航栏 -->
  <header class="fixed top-0 left-0 right-0 z-50 bg-white/90 backdrop-blur shadow-sm">
    <div class="container mx-auto px-4 py-3 flex items-center justify-between">
      <div class="flex items-center space-x-2">
        <i class="fa fa-book text-primary text-2xl"></i>
        <h1 class="text-xl font-bold bg-gradient-to-r from-primary to-secondary bg-clip-text text-transparent">StoryForge</h1>
      </div>
      
      <nav class="hidden md:flex items-center space-x-8">
        <a href="index.html" class="font-medium hover:text-primary transition-colors">首页</a>
        <a href="explore.html" class="font-medium hover:text-primary transition-colors">探索故事</a>
        <a href="create.html" class="font-medium hover:text-primary transition-colors">创建故事</a>
        <a href="my_stories.html" class="font-medium hover:text-primary transition-colors">我的作品</a>
        <a href="about.html" class="font-medium hover:text-primary transition-colors">关于</a>
      </nav>
      
      <!-- 已登录状态 - 桌面端 -->
      <div id="user-logged-in" class="hidden md:flex items-center space-x-4">
        <div class="relative group">
          <button class="flex items-center space-x-2 focus:outline-none">
            <div class="w-8 h-8 rounded-full bg-slate-200 flex items-center justify-center text-primary">
              <i class="fa fa-user"></i>
            </div>
            <span class="font-medium" id="username-display">用户名</span>
            <i class="fa fa-caret-down text-xs"></i>
          </button>
          <!-- 下拉菜单 -->
          <div class="absolute right-0 mt-2 w-48 bg-white rounded-lg shadow-lg py-2 hidden group-hover:block z-10">
            <a href="profile.html" class="block px-4 py-2 text-sm text-slate-700 hover:bg-slate-100">个人设置</a>
            <a href="my_stories.html" class="block px-4 py-2 text-sm text-slate-700 hover:bg-slate-100">我的作品</a>
            <div class="border-t border-slate-200 my-1"></div>
            <button id="logout-button-desktop" class="w-full text-left px-4 py-2 text-sm text-red-600 hover:bg-slate-100">退出登录</button>
          </div>
        </div>
      </div>
      
      <!-- 未登录状态 - 桌面端 -->
      <div id="user-not-logged-in" class="hidden md:flex items-center space-x-4">
        <a href="login.html" class="font-medium text-slate-700 hover:text-primary transition-colors">登录</a>
        <a href="register.html" class="px-4 py-2 bg-primary text-white rounded-lg hover:bg-primary/90 transition-colors">注册</a>
      </div>
      <div class="flex items-center space-x-4 md:hidden">
        <button class="text-xl" id="mobile-menu-button">
          <i class="fa fa-bars"></i>
        </button>
      </div>
    </div>
    
    <!-- 移动端菜单 -->
    <div class="md:hidden hidden bg-white shadow-lg absolute w-full" id="mobile-menu">
      <div class="container mx-auto px-4 py-3 flex flex-col space-y-4">
        <a href="index.html" class="font-medium py-2 hover:text-primary transition-colors">首页</a>
        <a href="explore.html" class="font-medium py-2 hover:text-primary transition-colors">探索故事</a>
        <a href="create.html" class="font-medium py-2 hover:text-primary transition-colors">创建故事</a>
        <a href="my_stories.html" class="font-medium py-2 hover:text-primary transition-colors">我的作品</a>
        <a href="about.html" class="font-medium py-2 hover:text-primary transition-colors">关于</a>
        <!-- 已登录状态 - 移动端 -->
      <div id="user-logged-in-mobile" class="hidden pt-2 space-y-3">
        <a href="my_stories.html" class="block font-medium py-2 hover:text-primary transition-colors">我的作品</a>
        <a href="profile.html" class="block font-medium py-2 hover:text-primary transition-colors">个人设置</a>
        <div class="border-t border-slate-200 my-1"></div>
        <button id="logout-button-mobile" class="w-full text-left font-medium py-2 text-red-600">退出登录</button>
      </div>
      
      <!-- 未登录状态 - 移动端 -->
      <div id="user-not-logged-in-mobile" class="hidden pt-2 space-y-3">
        <a href="login.html" class="block font-medium py-2 hover:text-primary transition-colors">登录</a>
        <a href="register.html" class="block px-4 py-2 bg-primary text-white rounded-lg hover:bg-primary/90 transition-colors text-center">注册</a>
      </div>
      </div>
    </div>
  </header>

  <!-- 主要内容区 -->
  <section class="pt-24 pb-20 px-4">
    <div class="container mx-auto max-w-6xl">
      <!-- 标题与操作区 -->
      <div class="flex flex-col md:flex-row justify-between items-start md:items-center mb-6 gap-4">
        <div>
          <h2 class="text-2xl font-bold mb-1">故事节点图谱</h2>
          <p class="text-slate-500" id="current-story-title">所属故事：魔法森林的神秘之门</p>
        </div>
        <div class="flex gap-3 w-full md:w-auto">
          <button id="new-node" class="flex-1 md:flex-none px-4 py-2 bg-primary text-white rounded-lg hover:bg-primary/90 transition-colors flex items-center justify-center">
            <i class="fa fa-plus mr-2"></i> 添加新节点
          </button>
          <button id="save-graph" class="flex-1 md:flex-none px-4 py-2 bg-white border border-slate-200 rounded-lg hover:bg-slate-50 transition-colors flex items-center justify-center">
            <i class="fa fa-save mr-2"></i> 保存图谱
          </button>
          <button id="export-story" class="flex-1 md:flex-none px-4 py-2 bg-white border border-slate-200 rounded-lg hover:bg-slate-50 transition-colors flex items-center justify-center">
            <i class="fa fa-download mr-2"></i> 导出故事
          </button>
        </div>
      </div>
      
      <!-- 操作面板 -->
      <div class="bg-white rounded-2xl shadow-xl p-4 mb-6 flex flex-wrap gap-3 justify-between items-center">
        <div class="flex flex-wrap gap-2">
          <button id="zoom-in" class="px-3 py-1.5 bg-white border border-slate-200 rounded-lg hover:bg-slate-50 transition-colors flex items-center">
            <i class="fa fa-search-plus"></i>
          </button>
          <button id="zoom-out" class="px-3 py-1.5 bg-white border border-slate-200 rounded-lg hover:bg-slate-50 transition-colors flex items-center">
            <i class="fa fa-search-minus"></i>
          </button>
          <button id="reset-view" class="px-3 py-1.5 bg-white border border-slate-200 rounded-lg hover:bg-slate-50 transition-colors flex items-center">
            <i class="fa fa-refresh"></i>
          </button>
          <button id="auto-arrange" class="px-3 py-1.5 bg-white border border-slate-200 rounded-lg hover:bg-slate-50 transition-colors flex items-center">
            <i class="fa fa-th-large"></i> 自动排列
          </button>
        </div>
        <div class="flex items-center gap-3">
          <div class="text-sm text-slate-500">
            节点数量：<span id="nodes-count">0</span>
          </div>
          <div class="relative">
            <select id="node-type-filter" class="px-3 py-1.5 bg-white border border-slate-200 rounded-lg focus:outline-none focus:ring-2 focus:ring-primary">
              <option value="all">所有节点类型</option>
              <option value="normal">普通节点</option>
              <option value="choice">选择节点</option>
              <option value="climax">高潮节点</option>
              <option value="ending">结局节点</option>
            </select>
          </div>
        </div>
      </div>
      
      <!-- 节点图谱区域 -->
      <div class="relative bg-white rounded-2xl shadow-xl p-4">
        <div id="node-grid" class="node-grid rounded-xl p-4 relative overflow-auto">
          <!-- 节点和连接线将动态生成 -->
          <div id="connection-layer" class="absolute top-4 left-4 w-[calc(100%-2rem)] h-[calc(100%-2rem)]"></div>
          <div id="nodes-layer" class="absolute top-4 left-4 w-[calc(100%-2rem)] h-[calc(100%-2rem)]"></div>
          
          <!-- 中心提示 -->
          <div id="empty-state" class="absolute inset-0 flex flex-col items-center justify-center">
            <i class="fa fa-sitemap text-6xl text-slate-300 mb-4"></i>
            <h3 class="text-xl font-medium text-slate-500 mb-2">暂无节点</h3>
            <p class="text-slate-400 mb-6">点击"添加新节点"开始创建故事图谱</p>
            <button id="start-now" class="px-4 py-2 bg-primary text-white rounded-lg hover:bg-primary/90 transition-colors flex items-center">
              <i class="fa fa-plus mr-2"></i> 添加第一个节点
            </button>
          </div>
        </div>
      </div>
    </div>
  </section>

  <script src="assets/js/auth.js"></script>
  <script>
    // 当前故事ID
    let currentStoryId = null;
    // 是否处于查看模式
    let viewMode = false;
    // 节点图谱数据结构
    let graphData = {
      nodes: {},         // { id: { id, title, content, type, position: {x,y} } }
      connections: []    // { from: id, to: id, description: "连接描述" }
    };
    // 缩放和位置状态
    let scale = 1;
    let offset = { x: 0, y: 0 };
    let isDragging = false;
    let dragStart = { x: 0, y: 0 };
    let selectedNode = null;
    let connectingNode = null;
    let tempConnection = null;
    
    // 移动端菜单切换
    const mobileMenuButton = document.getElementById('mobile-menu-button');
    const mobileMenu = document.getElementById('mobile-menu');
    if (mobileMenuButton && mobileMenu) {
      mobileMenuButton.addEventListener('click', () => {
        mobileMenu.classList.toggle('hidden');
      });
    }
    
    // 检查登录状态
    function checkLoginStatus() {
      const token = localStorage.getItem('token') || sessionStorage.getItem('token');
      const userInfo = JSON.parse(localStorage.getItem('userInfo') || sessionStorage.getItem('userInfo') || '{}');
      
      const userLoggedInDesktop = document.getElementById('user-logged-in');
      const userNotLoggedInDesktop = document.getElementById('user-not-logged-in');
      const userLoggedInMobile = document.getElementById('user-logged-in-mobile');
      const userNotLoggedInMobile = document.getElementById('user-not-logged-in-mobile');
      const usernameDisplay = document.getElementById('username-display');
      
      if (token && userInfo.username) {
        // 已登录状态
        if (userLoggedInDesktop) userLoggedInDesktop.classList.remove('hidden');
        if (userNotLoggedInDesktop) userNotLoggedInDesktop.classList.add('hidden');
        if (userLoggedInMobile) userLoggedInMobile.classList.remove('hidden');
        if (userNotLoggedInMobile) userNotLoggedInMobile.classList.add('hidden');
        if (usernameDisplay) usernameDisplay.textContent = userInfo.username;
      } else {
        // 未登录状态
        if (userLoggedInDesktop) userLoggedInDesktop.classList.add('hidden');
        if (userNotLoggedInDesktop) userNotLoggedInDesktop.classList.remove('hidden');
        if (userLoggedInMobile) userLoggedInMobile.classList.add('hidden');
        if (userNotLoggedInMobile) userNotLoggedInMobile.classList.remove('hidden');
      }
    }
    
    // 退出登录功能
    function setupLogout() {
      const logoutButtonDesktop = document.getElementById('logout-button-desktop');
      const logoutButtonMobile = document.getElementById('logout-button-mobile');
      
      function logout() {
        // 清除存储的信息
        localStorage.removeItem('token');
        localStorage.removeItem('refreshToken');
        localStorage.removeItem('userInfo');
        sessionStorage.removeItem('token');
        sessionStorage.removeItem('refreshToken');
        sessionStorage.removeItem('userInfo');
        
        // 更新UI
        checkLoginStatus();
        
        // 显示通知
        showNotification('已成功退出登录', 'success');
        
        // 如果在需要登录的页面，可以重定向到登录页
        if (!viewMode) {
          window.location.href = 'login.html';
        }
      }
      
      if (logoutButtonDesktop) logoutButtonDesktop.addEventListener('click', logout);
      if (logoutButtonMobile) logoutButtonMobile.addEventListener('click', logout);
    }
    
    // 添加导航栏功能的登录检查
    function setupNavLinksAuth() {
      // 获取所有导航链接并添加点击事件
      const navLinks = document.querySelectorAll('nav a, #mobile-menu a');
      navLinks.forEach(link => {
        // 为需要认证的页面添加检查
        if (link.href.includes('create.html') || link.href.includes('my_stories.html')) {
          link.addEventListener('click', function(e) {
            const token = localStorage.getItem('token') || sessionStorage.getItem('token');
            if (!token) {
              e.preventDefault();
              showNotification('请先登录', 'error');
              // 保存当前页面作为返回地址
              window.location.href = `login.html?redirect=${encodeURIComponent(window.location.pathname)}`;
            }
          });
        }
      });
    }
    
    // 初始化认证UI
    setupLogout();
    setupNavLinksAuth();

    // 页面加载时获取数据
    window.addEventListener('DOMContentLoaded', function() {
      // 从URL获取故事ID和查看模式参数
      const params = new URLSearchParams(window.location.search);
      currentStoryId = params.get('story') || params.get('id') || 'default';
      const isViewMode = params.get('view') === 'true' || params.get('mode') === 'read';
      const returnedFromEditor = params.get('returned') === 'true';
      
      // 如果没有故事ID，可以使用默认值或创建新故事
      if (!currentStoryId) {
        currentStoryId = 'default';
        // 在默认模式下禁用查看模式
        viewMode = false;
      }
      
      // 设置查看模式
      viewMode = isViewMode;
      
      // 如果是查看模式，禁用编辑功能
      if (viewMode) {
        // 隐藏编辑相关按钮
        const editButtons = ['new-node', 'save-graph', 'export-story', 'auto-arrange'];
        editButtons.forEach(id => {
          const btn = document.getElementById(id);
          if (btn) btn.style.display = 'none';
        });
        
        // 隐藏或禁用筛选功能
        document.getElementById('node-type-filter').style.display = 'none';
        
        // 更新标题显示为查看模式
        const titleElement = document.querySelector('h2.text-2xl.font-bold');
        if (titleElement) titleElement.textContent = '故事节点图谱 - 查看模式';
      }
      
      // 检查登录状态
      checkLoginStatus();
      
      // 加载图谱数据
      loadGraphData();
      
      // 恢复之前保存的缩放状态，优先处理从编辑器返回的情况
      if (returnedFromEditor && currentStoryId && currentStoryId !== 'default') {
        try {
          const savedScale = localStorage.getItem(`storyScale_${currentStoryId}`);
          const savedOffset = localStorage.getItem(`storyOffset_${currentStoryId}`);
          
          if (savedScale !== null) {
            scale = parseFloat(savedScale);
          }
          if (savedOffset !== null) {
            offset = JSON.parse(savedOffset);
          }
          
          // 等待DOM渲染完成后应用变换
          setTimeout(() => {
            updateTransform();
          }, 100);
          
          console.log('已恢复画布缩放状态');
        } catch (e) {
          console.error('恢复画布状态失败', e);
        }
      } else if (currentStoryId && currentStoryId !== 'default') {
        // 常规情况也尝试恢复状态
        const savedScale = localStorage.getItem(`storyScale_${currentStoryId}`);
        const savedOffset = localStorage.getItem(`storyOffset_${currentStoryId}`);
        
        if (savedScale) {
          scale = parseFloat(savedScale);
        }
        
        if (savedOffset) {
          try {
            offset = JSON.parse(savedOffset);
          } catch (e) {
            console.error('解析保存的偏移量失败', e);
          }
        }
        
        // 应用保存的变换
        updateTransform();
      }
      
      // 绑定事件
      bindEvents();
    });
    
    // 加载图谱数据
    function loadGraphData() {
      // 从本地存储获取数据
      const savedData = localStorage.getItem('storyGraphData');
      if (savedData) {
        try {
          graphData = JSON.parse(savedData);
          // 检查是否有节点
          if (Object.keys(graphData.nodes).length > 0) {
            document.getElementById('empty-state').style.display = 'none';
          }
          // 更新节点计数
          document.getElementById('nodes-count').textContent = Object.keys(graphData.nodes).length;
          // 渲染图谱
          renderGraph();
        } catch (e) {
          console.error('解析图谱数据失败', e);
          showNotification('加载图谱数据失败', 'error');
        }
      }
      
      // 尝试从后端加载数据
      if (currentStoryId && currentStoryId !== 'default') {
        fetchStoryFromBackend(currentStoryId);
      }
    }
    
    // 从后端加载故事数据
    async function fetchStoryFromBackend(storyId) {
      try {
        // 获取token（如果有）
        const token = localStorage.getItem('token') || sessionStorage.getItem('token');
        
        // 准备请求头
        const headers = {};
        if (token) {
          headers['Authorization'] = `Bearer ${token}`;
        }
        
        // 首先获取故事章节
        const sectionsResponse = await fetch(`http://localhost:5000/api/v1/sections/${storyId}`, {
          headers: headers
        });
        const sectionsData = await sectionsResponse.json();
        
        if (sectionsData.success) {
          // 构建图谱数据
          const nodes = {};
          const connections = [];
          
          // 先创建所有节点
          sectionsData.data.forEach((section, index) => {
            // 计算节点位置（使用更合理的网格布局）
            const x = 200 + (index % 4) * 350;
            const y = 100 + Math.floor(index / 4) * 250;
            
            // 确定节点类型
            let nodeType = 'normal';
            if (section.type === 'choice') {
              nodeType = 'choice';
            } else if (section.isEnd) {
              nodeType = 'ending';
            }
            
            nodes[section.id] = {
              id: section.id,
              title: section.title || `节点 ${index + 1}`,
              content: section.text,
              type: nodeType,
              position: { x, y }
            };
            
            // 处理分支连接
            if (section.choices && Array.isArray(section.choices)) {
              section.choices.forEach(choice => {
                if (choice.nextSectionId) {
                  connections.push({
                    from: section.id,
                    to: choice.nextSectionId,
                    description: choice.text || '继续'
                  });
                }
              });
            }
          });
          
          graphData = { nodes, connections };
          
          // 更新界面
          document.getElementById('empty-state').style.display = 'none';
          document.getElementById('nodes-count').textContent = Object.keys(nodes).length;
          renderGraph();
          showNotification('成功加载故事图谱', 'success');
        } else {
          console.error('获取章节失败:', sectionsData.message);
          showNotification('加载故事章节失败', 'error');
        }
        
        // 获取故事标题
        const storyResponse = await fetch(`http://localhost:5000/api/v1/stories/${storyId}`, {
          headers: headers
        });
        const storyData = await storyResponse.json();
        
        if (storyData.success) {
          document.getElementById('current-story-title').textContent = `所属故事：${storyData.data.title}`;
        } else {
          console.error('获取故事信息失败:', storyData.message);
        }
      } catch (error) {
        console.error('从后端加载故事失败', error);
        showNotification('无法连接到服务器，使用本地数据', 'warning');
        // 后端加载失败不显示错误，继续使用本地存储数据
      }
    }
    
    // 渲染图谱
    function renderGraph() {
      const nodesLayer = document.getElementById('nodes-layer');
      const connectionLayer = document.getElementById('connection-layer');
      
      // 清空现有内容
      nodesLayer.innerHTML = '';
      connectionLayer.innerHTML = '';
      
      // 先渲染连接线
      graphData.connections.forEach(connection => {
        if (connection.from && connection.to) {
          const fromNode = graphData.nodes[connection.from];
          const toNode = graphData.nodes[connection.to];
          
          if (fromNode && toNode) {
            createConnection(connection, fromNode, toNode, connectionLayer);
          }
        }
      });
      
      // 然后渲染节点
      Object.values(graphData.nodes).forEach(node => {
        createNode(node, nodesLayer);
      });
    }
    
    // 创建连接线
    function createConnection(connection, fromNode, toNode, parent) {
      const line = document.createElement('div');
      line.className = 'connection-line';
      line.dataset.from = connection.from;
      line.dataset.to = connection.to;
      
      // 计算节点中心点
      const fromX = fromNode.position.x + 150; // 节点宽度的一半
      const fromY = fromNode.position.y + 75; // 节点高度的一半
      const toX = toNode.position.x + 150;
      const toY = toNode.position.y + 75;
      
      // 计算线条角度和长度
      const dx = toX - fromX;
      const dy = toY - fromY;
      const distance = Math.sqrt(dx * dx + dy * dy);
      const angle = Math.atan2(dy, dx) * 180 / Math.PI;
      
      // 设置线条样式
      line.style.left = `${fromX}px`;
      line.style.top = `${fromY}px`;
      line.style.width = `${distance}px`;
      line.style.transform = `rotate(${angle}deg)`;
      line.style.transformOrigin = '0 0';
      line.style.height = '2px';
      
      // 添加连接线标签容器
      const labelContainer = document.createElement('div');
      labelContainer.className = 'absolute whitespace-nowrap';
      labelContainer.style.left = `50%`;
      labelContainer.style.top = '-12px';
      labelContainer.style.transform = `translateX(-50%)`;
      
      // 创建可编辑的标签
      const label = document.createElement('div');
      label.className = 'bg-white px-2 py-1 rounded text-xs font-medium text-slate-600 shadow-sm cursor-pointer hover:bg-slate-50 transition-colors';
      label.textContent = connection.description || '点击编辑';
      
      // 添加双击编辑功能
      label.addEventListener('dblclick', function(e) {
        e.stopPropagation();
        
        const input = document.createElement('input');
        input.type = 'text';
        input.value = connection.description || '';
        input.className = 'px-2 py-1 text-xs font-medium text-slate-600 border border-slate-300 rounded focus:outline-none focus:ring-1 focus:ring-primary';
        input.style.width = '150px';
        
        labelContainer.innerHTML = '';
        labelContainer.appendChild(input);
        input.focus();
        
        // 处理编辑完成
        input.addEventListener('blur', function() {
          saveConnectionDescription(connection, input.value);
        });
        
        input.addEventListener('keydown', function(e) {
          if (e.key === 'Enter') {
            saveConnectionDescription(connection, input.value);
          } else if (e.key === 'Escape') {
            renderConnectionLabel(labelContainer, connection);
          }
        });
      });
      
      labelContainer.appendChild(label);
      line.appendChild(labelContainer);
      
      parent.appendChild(line);
    }
    
    // 渲染连接线标签
    function renderConnectionLabel(container, connection) {
      const label = document.createElement('div');
      label.className = 'bg-white px-2 py-1 rounded text-xs font-medium text-slate-600 shadow-sm cursor-pointer hover:bg-slate-50 transition-colors';
      label.textContent = connection.description || '点击编辑';
      
      label.addEventListener('dblclick', function(e) {
        e.stopPropagation();
        
        const input = document.createElement('input');
        input.type = 'text';
        input.value = connection.description || '';
        input.className = 'px-2 py-1 text-xs font-medium text-slate-600 border border-slate-300 rounded focus:outline-none focus:ring-1 focus:ring-primary';
        input.style.width = '150px';
        
        container.innerHTML = '';
        container.appendChild(input);
        input.focus();
        
        input.addEventListener('blur', function() {
          saveConnectionDescription(connection, input.value);
        });
        
        input.addEventListener('keydown', function(e) {
          if (e.key === 'Enter') {
            saveConnectionDescription(connection, input.value);
          } else if (e.key === 'Escape') {
            renderConnectionLabel(container, connection);
          }
        });
      });
      
      container.innerHTML = '';
      container.appendChild(label);
    }
    
    // 保存连接线描述
    function saveConnectionDescription(connection, description) {
      connection.description = description.trim() || '无描述';
      renderConnections(); // 重新渲染所有连接线以更新标签
      saveGraphData();
      
      // 同步更新到后端数据结构
      if (currentStoryId && currentStoryId !== 'default') {
        // 这里可以添加同步到后端的逻辑
      }
    }
    
    // 创建节点
    function createNode(node, parent) {
      const nodeEl = document.createElement('div');
      nodeEl.className = `node absolute p-4 rounded-lg shadow-md border-2 node-type-${node.type} min-w-[300px] max-w-[400px]`;
      nodeEl.style.left = `${node.position.x}px`;
      nodeEl.style.top = `${node.position.y}px`;
      nodeEl.dataset.nodeId = node.id;
      
      // 根据模式设置节点内容
      let actionButtons = '';
      if (!viewMode) {
        actionButtons = `
          <div class="flex gap-1">
            <button class="connect-node-btn p-1 hover:text-primary transition-colors" title="创建连接">
              <i class="fa fa-link"></i>
            </button>
            <button class="delete-node-btn p-1 hover:text-red-500 transition-colors" title="删除节点">
              <i class="fa fa-trash"></i>
            </button>
          </div>
        `;
      }
      
      let editButton = '';
      if (!viewMode) {
        editButton = `<button class="edit-node-btn text-xs px-2 py-1 bg-primary/10 text-primary rounded hover:bg-primary/20 transition-colors">
          编辑
        </button>`;
      }
      
      // 确保节点类型有效
      const nodeType = node.type || 'normal';
      nodeEl.classList.add(`node-type-${nodeType}`);
      
      // 节点内容
      nodeEl.innerHTML = `
        <div class="flex justify-between items-start mb-2">
          <h3 class="font-bold text-sm truncate" title="${node.title}">${node.title}</h3>
          ${actionButtons}
        </div>
        <p class="text-xs text-slate-500 line-clamp-3 mb-2" title="${node.content || '无内容'}">${node.content || '无内容'}</p>
        <div class="flex justify-between items-center">
          <span class="text-xs px-2 py-0.5 rounded-full bg-slate-100 text-slate-600">${getNodeTypeLabel(node.type)}</span>
          ${editButton}
        </div>
      `;
      
      // 如果不是查看模式，添加交互功能
      if (!viewMode) {
        // 绑定拖动事件
        makeNodeDraggable(nodeEl, node);
        
        // 绑定编辑事件
        if (nodeEl.querySelector('.edit-node-btn')) {
          nodeEl.querySelector('.edit-node-btn').addEventListener('click', function() {
            window.location.href = `story_editor.html?story=${currentStoryId}&node=${node.id}`;
          });
        }
        
        // 绑定删除事件
        if (nodeEl.querySelector('.delete-node-btn')) {
          nodeEl.querySelector('.delete-node-btn').addEventListener('click', function(e) {
            e.stopPropagation();
            deleteNode(node.id);
          });
        }
        
        // 绑定连接事件
        if (nodeEl.querySelector('.connect-node-btn')) {
          nodeEl.querySelector('.connect-node-btn').addEventListener('click', function(e) {
            e.stopPropagation();
            startConnection(node.id);
          });
        }
      } else {
        // 查看模式下，点击节点显示完整内容
        nodeEl.style.cursor = 'pointer';
        nodeEl.addEventListener('click', function() {
          // 可以在这里实现弹出详情窗口或其他查看功能
          alert(`节点: ${node.title}\n\n内容: ${node.content}`);
        });
      }
      
      parent.appendChild(nodeEl);
    }
    
    // 获取节点类型标签
    function getNodeTypeLabel(type) {
      const labels = {
        normal: '普通',
        choice: '选择',
        climax: '高潮',
        ending: '结局'
      };
      return labels[type] || '未知';
    }
    
    // 自动滚动画布的函数
    function autoScrollCanvas(e) {
      const grid = document.getElementById('node-grid');
      const gridRect = grid.getBoundingClientRect();
      const scrollMargin = 50; // 距离边缘触发滚动的距离
      const scrollSpeed = 5; // 滚动速度
      
      // 检查是否接近左边缘
      if (e.clientX < gridRect.left + scrollMargin) {
        grid.scrollLeft -= scrollSpeed;
      }
      // 检查是否接近右边缘
      if (e.clientX > gridRect.right - scrollMargin) {
        grid.scrollLeft += scrollSpeed;
      }
      // 检查是否接近上边缘
      if (e.clientY < gridRect.top + scrollMargin) {
        grid.scrollTop -= scrollSpeed;
      }
      // 检查是否接近下边缘
      if (e.clientY > gridRect.bottom - scrollMargin) {
        grid.scrollTop += scrollSpeed;
      }
    }
    
    // 使节点可拖动
    function makeNodeDraggable(element, nodeData) {
      let isDragging = false;
      let offset = { x: 0, y: 0 };
      let lastRenderTime = 0;
      const RENDER_THROTTLE = 16; // 约60fps
      
      element.addEventListener('mousedown', function(e) {
        // 如果点击的是按钮，不触发拖动
        if (e.target.closest('button')) return;
        
        // 阻止默认行为以防止文本选择
        e.preventDefault();
        
        isDragging = true;
        const rect = element.getBoundingClientRect();
        // 使用getBoundingClientRect获取准确的偏移，避免节点脱离鼠标
        offset.x = e.clientX - rect.left;
        offset.y = e.clientY - rect.top;
        
        // 设置选中状态
        if (selectedNode) {
          const prevSelected = document.querySelector(`[data-node-id="${selectedNode}"]`);
          if (prevSelected) {
            prevSelected.classList.remove('ring-2', 'ring-primary');
          }
        }
        selectedNode = nodeData.id;
        element.classList.add('ring-2', 'ring-primary');
        
        // 添加拖动时的视觉反馈
        element.classList.add('dragging');
      });
      
      document.addEventListener('mousemove', function(e) {
        if (!isDragging) return;
        
        // 自动滚动画布
        autoScrollCanvas(e);
        
        const grid = document.getElementById('node-grid');
        const gridRect = grid.getBoundingClientRect();
        
        // 计算新位置
        const newX = e.clientX - gridRect.left - offset.x;
        const newY = e.clientY - gridRect.top - offset.y;
        
        // 更新节点位置
        element.style.left = `${newX}px`;
        element.style.top = `${newY}px`;
        
        // 更新数据
        nodeData.position.x = newX;
        nodeData.position.y = newY;
        
        // 节流渲染连接线，提高性能
        const currentTime = Date.now();
        if (currentTime - lastRenderTime > RENDER_THROTTLE) {
          renderConnections();
          lastRenderTime = currentTime;
        }
      });
      
      document.addEventListener('mouseup', function() {
        if (isDragging) {
          isDragging = false;
          
          // 移除拖动时的视觉效果
          element.classList.remove('dragging');
          element.style.zIndex = '10';
          
          // 拖动结束时强制更新一次连接线
          renderConnections();
          saveGraphData(); // 拖动结束后自动保存
        }
      });
      
      // 防止文本选择
      element.addEventListener('selectstart', function(e) {
        e.preventDefault();
        return false;
      });
    }
    
    // 重新渲染所有连接线
    function renderConnections() {
      const connectionLayer = document.getElementById('connection-layer');
      connectionLayer.innerHTML = '';
      
      graphData.connections.forEach(connection => {
        if (connection.from && connection.to) {
          const fromNode = graphData.nodes[connection.from];
          const toNode = graphData.nodes[connection.to];
          
          if (fromNode && toNode) {
            createConnection(connection, fromNode, toNode, connectionLayer);
          }
        }
      });
    }
    
    // 开始创建连接
    function startConnection(nodeId) {
      connectingNode = nodeId;
      
      // 设置鼠标样式
      document.body.style.cursor = 'crosshair';
      
      // 高亮源节点
      const sourceNode = document.querySelector(`[data-node-id="${nodeId}"]`);
      if (sourceNode) {
        sourceNode.classList.add('ring-2', 'ring-primary', 'ring-offset-2');
      }
      
      // 显示提示
      showNotification('点击目标节点完成连接，或点击空白处取消', 'info');
    }
    
    // 删除节点
    function deleteNode(nodeId) {
      if (confirm('确定要删除此节点吗？所有关联的连接也会被删除')) {
        // 从数据中删除节点
        delete graphData.nodes[nodeId];
        
        // 删除所有关联的连接
        graphData.connections = graphData.connections.filter(
          conn => conn.from !== nodeId && conn.to !== nodeId
        );
        
        // 更新界面
        renderGraph();
        document.getElementById('nodes-count').textContent = Object.keys(graphData.nodes).length;
        
        // 如果没有节点了，显示空状态
        if (Object.keys(graphData.nodes).length === 0) {
          document.getElementById('empty-state').style.display = 'flex';
        }
        
        // 保存数据
        saveGraphData();
        
        showNotification('节点已删除', 'success');
      }
    }
    
    // 保存图谱数据
    function saveGraphData() {
      try {
        localStorage.setItem('storyGraphData', JSON.stringify(graphData));
        return true;
      } catch (e) {
        console.error('保存图谱数据失败', e);
        return false;
      }
    }
    
    // 绑定页面事件
    function bindEvents() {
      // 新节点按钮
      document.getElementById('new-node').addEventListener('click', function() {
        createNewNode();
      });
      
      // 开始按钮
      document.getElementById('start-now').addEventListener('click', function() {
        createNewNode();
      });
      
      // 保存图谱按钮
      document.getElementById('save-graph').addEventListener('click', function() {
        if (saveGraphData()) {
          // 尝试保存到后端
          if (currentStoryId && currentStoryId !== 'default') {
            saveGraphToBackend();
          }
          showNotification('图谱已保存', 'success');
        } else {
          showNotification('保存失败', 'error');
        }
      });
      
      // 导出故事按钮
      document.getElementById('export-story').addEventListener('click', function() {
        exportStory();
      });
      
      // 缩放按钮
      document.getElementById('zoom-in').addEventListener('click', function() {
        scale = Math.min(scale + 0.1, 2);
        updateTransform();
      });
      
      document.getElementById('zoom-out').addEventListener('click', function() {
        scale = Math.max(scale - 0.1, 0.5);
        updateTransform();
      });
      
      // 重置视图
      document.getElementById('reset-view').addEventListener('click', function() {
        scale = 1;
        offset = { x: 0, y: 0 };
        updateTransform();
      });
      
      // 自动排列
      document.getElementById('auto-arrange').addEventListener('click', function() {
        arrangeNodes();
      });
      
      // 类型筛选
      document.getElementById('node-type-filter').addEventListener('change', function() {
        filterNodes(this.value);
      });
      
      // 处理画布拖动
      const nodeGrid = document.getElementById('node-grid');
      
      // 全局阻止画布内的文本选择，防止拖动时全选
      nodeGrid.addEventListener('selectstart', function(e) {
        e.preventDefault();
        return false;
      });
      
      // 画布拖动事件
      nodeGrid.addEventListener('mousedown', function(e) {
        // 只有在空白区域点击才触发拖动
        if (e.target === nodeGrid || e.target === document.getElementById('connection-layer')) {
          // 阻止默认行为以防止文本选择和拖动
          e.preventDefault();
          
          isDragging = true;
          dragStart.x = e.clientX - offset.x;
          dragStart.y = e.clientY - offset.y;
          
          // 设置拖动时的光标
          nodeGrid.style.cursor = 'grabbing';
          
          // 取消连接模式
          if (connectingNode) {
            const sourceNode = document.querySelector(`[data-node-id="${connectingNode}"]`);
            if (sourceNode) {
              sourceNode.classList.remove('ring-2', 'ring-primary', 'ring-offset-2');
            }
            connectingNode = null;
            document.body.style.cursor = 'default';
          }
        }
      });
      
      document.addEventListener('mousemove', function(e) {
        if (isDragging) {
          // 更积极的自动滚动画布实现
          const grid = document.getElementById('node-grid');
          const gridRect = grid.getBoundingClientRect();
          const scrollMargin = 80; // 增大触发滚动的边距
          const scrollSpeed = 8; // 提高滚动速度
          
          // 检查并执行自动滚动
          let needsScroll = false;
          
          if (e.clientX < gridRect.left + scrollMargin) {
            grid.scrollLeft -= scrollSpeed;
            needsScroll = true;
          }
          if (e.clientX > gridRect.right - scrollMargin) {
            grid.scrollLeft += scrollSpeed;
            needsScroll = true;
          }
          if (e.clientY < gridRect.top + scrollMargin) {
            grid.scrollTop -= scrollSpeed;
            needsScroll = true;
          }
          if (e.clientY > gridRect.bottom - scrollMargin) {
            grid.scrollTop += scrollSpeed;
            needsScroll = true;
          }
          
          // 只有在没有自动滚动时才更新位置，避免冲突
          if (!needsScroll) {
            offset.x = e.clientX - dragStart.x;
            offset.y = e.clientY - dragStart.y;
            updateTransform();
          }
        } else if (connectingNode) {
          // 显示临时连接线
          if (tempConnection) {
            tempConnection.remove();
          }
          
          const sourceNode = document.querySelector(`[data-node-id="${connectingNode}"]`);
          if (sourceNode) {
            const rect = sourceNode.getBoundingClientRect();
            const gridRect = nodeGrid.getBoundingClientRect();
            
            const fromX = rect.left - gridRect.left + rect.width / 2;
            const fromY = rect.top - gridRect.top + rect.height / 2;
            const toX = e.clientX - gridRect.left;
            const toY = e.clientY - gridRect.top;
            
            tempConnection = document.createElement('div');
            tempConnection.className = 'absolute bg-primary/50';
            
            const dx = toX - fromX;
            const dy = toY - fromY;
            const distance = Math.sqrt(dx * dx + dy * dy);
            const angle = Math.atan2(dy, dx) * 180 / Math.PI;
            
            tempConnection.style.left = `${fromX}px`;
            tempConnection.style.top = `${fromY}px`;
            tempConnection.style.width = `${distance}px`;
            tempConnection.style.height = '2px';
            tempConnection.style.transform = `rotate(${angle}deg)`;
            tempConnection.style.transformOrigin = '0 0';
            tempConnection.style.zIndex = 1;
            
            nodeGrid.appendChild(tempConnection);
          }
        }
      });
      
      document.addEventListener('mouseup', function() {
        if (isDragging) {
          isDragging = false;
          // 恢复光标
          document.getElementById('node-grid').style.cursor = 'grab';
        }
      });
      
      // 鼠标离开画布时也应该停止拖动
      document.getElementById('node-grid').addEventListener('mouseleave', function() {
        if (isDragging) {
          isDragging = false;
          nodeGrid.style.cursor = 'grab';
        }
      });
      
      // 处理节点点击完成连接
      nodeGrid.addEventListener('click', function(e) {
        const targetNode = e.target.closest('.node');
        if (connectingNode && targetNode) {
          const targetNodeId = targetNode.dataset.nodeId;
          
          // 不能连接自己
          if (connectingNode !== targetNodeId) {
            // 检查是否已有相同连接
            const exists = graphData.connections.some(conn => 
              conn.from === connectingNode && conn.to === targetNodeId
            );
            
            if (!exists) {
              // 让用户输入分支描述
              const description = prompt('请输入连接描述（分支选择文本）:', '继续');
              
              if (description === null) {
                // 用户取消输入
                return;
              }
              
              // 添加连接
              graphData.connections.push({
                from: connectingNode,
                to: targetNodeId,
                description: description.trim() || '继续'
              });
              
              // 更新后端数据结构映射
              // 这里我们假设connections数组中的连接会在保存时转换为后端需要的格式
              // 每个连接会作为fromNode的一个choice，to作为nextSectionId
              
              // 渲染更新
              renderConnections();
              saveGraphData();
              showNotification('连接已创建', 'success');
            } else {
              showNotification('连接已存在', 'error');
            }
          } else {
            showNotification('不能连接到自身', 'error');
          }
          
          // 重置连接状态
          const sourceNode = document.querySelector(`[data-node-id="${connectingNode}"]`);
          if (sourceNode) {
            sourceNode.classList.remove('ring-2', 'ring-primary', 'ring-offset-2');
          }
          connectingNode = null;
          document.body.style.cursor = 'default';
          
          if (tempConnection) {
            tempConnection.remove();
            tempConnection = null;
          }
        }
      });
    }
    
    // 更新变换
    function updateTransform() {
      const nodesLayer = document.getElementById('nodes-layer');
      const connectionLayer = document.getElementById('connection-layer');
      
      const transform = `translate(${offset.x}px, ${offset.y}px) scale(${scale})`;
      nodesLayer.style.transform = transform;
      connectionLayer.style.transform = transform;
      
      // 设置transform-origin为左上角以保持缩放行为一致
      nodesLayer.style.transformOrigin = '0 0';
      connectionLayer.style.transformOrigin = '0 0';
    }
    
    // 创建新节点
    function createNewNode() {
      // 检查是否处于查看模式
      if (viewMode) {
        showNotification('查看模式下无法创建新节点', 'warning');
        return;
      }
      
      // 检查是否已登录
      const token = localStorage.getItem('token') || sessionStorage.getItem('token');
      if (!token) {
        showNotification('请先登录', 'error');
        // 保存当前页面作为返回地址
        window.location.href = `login.html?redirect=${encodeURIComponent(window.location.pathname + window.location.search)}`;
        return;
      }
      
      // 检查是否有有效的故事ID
      if (!currentStoryId || currentStoryId === 'default') {
        showNotification('请先创建故事', 'error');
        window.location.href = 'create.html';
        return;
      }
      
      // 保存当前缩放状态，以便返回时恢复
      localStorage.setItem(`storyScale_${currentStoryId}`, scale);
      localStorage.setItem(`storyOffset_${currentStoryId}`, JSON.stringify(offset));
      
      // 生成临时ID（实际ID将在后端生成）
      const nodeId = Date.now().toString().slice(-6);
      
      // 计算新节点的位置，基于当前视图中心
      const grid = document.getElementById('node-grid');
      const gridRect = grid.getBoundingClientRect();
      const centerX = gridRect.width / 2 - 150; // 减去节点宽度的一半
      const centerY = gridRect.height / 2 - 75;  // 减去节点高度的一半
      
      // 考虑当前画布的偏移量和缩放，确保新节点显示在视图中心
      // 反向应用当前的transform，让新节点显示在用户当前看到的中心位置
      const adjustedX = centerX - offset.x / scale;
      const adjustedY = centerY - offset.y / scale;
      
      // 添加一些随机偏移，避免节点完全重叠
      const randomOffsetX = (Math.random() - 0.5) * 100;
      const randomOffsetY = (Math.random() - 0.5) * 100;
      
      const newNode = {
        id: nodeId,
        title: "新节点",
        content: "在这里写下当前节点的故事内容...",
        type: "normal",
        position: { 
          x: adjustedX + randomOffsetX,
          y: adjustedY + randomOffsetY
        }
      };
      
      // 添加到数据
      graphData.nodes[nodeId] = newNode;
      
      // 更新界面
      document.getElementById('empty-state').style.display = 'none';
      document.getElementById('nodes-count').textContent = Object.keys(graphData.nodes).length;
      
      // 渲染新节点
      createNode(newNode, document.getElementById('nodes-layer'));
      
      // 保存数据到本地
      saveGraphData();
      
      // 跳转到编辑页面，并传递返回参数
      window.location.href = `story_editor.html?story=${currentStoryId}&node=${nodeId}&returnTo=story_tree.html`;
    }
    
    // 自动排列节点
    function arrangeNodes() {
      const nodes = Object.values(graphData.nodes);
      const nodeCount = nodes.length;
      
      if (nodeCount === 0) return;
      
      // 简单的网格布局
      const cols = Math.ceil(Math.sqrt(nodeCount));
      const rows = Math.ceil(nodeCount / cols);
      
      const nodeWidth = 350; // 包括间距
      const nodeHeight = 200; // 包括间距
      
      // 计算起始位置，使布局居中
      const startX = (document.getElementById('node-grid').offsetWidth - (cols * nodeWidth)) / 2;
      const startY = 50;
      
      nodes.forEach((node, index) => {
        const col = index % cols;
        const row = Math.floor(index / cols);
        
        node.position.x = startX + col * nodeWidth;
        node.position.y = startY + row * nodeHeight;
      });
      
      // 重置视图并渲染
      scale = 1;
      offset = { x: 0, y: 0 };
      updateTransform();
      renderGraph();
      
      // 保存数据
      saveGraphData();
      showNotification('节点已自动排列', 'success');
    }
    
    // 筛选节点
    function filterNodes(type) {
      const nodes = document.querySelectorAll('.node');
      
      nodes.forEach(node => {
        const nodeType = node.classList.contains('node-type-normal') ? 'normal' :
                         node.classList.contains('node-type-choice') ? 'choice' :
                         node.classList.contains('node-type-climax') ? 'climax' :
                         node.classList.contains('node-type-ending') ? 'ending' : '';
        
        if (type === 'all' || nodeType === type) {
          node.style.display = 'block';
        } else {
          node.style.display = 'none';
        }
      });
      
      // 重新渲染连接线（可选：隐藏连接到不可见节点的线）
      renderConnections();
    }
    
    // 保存到后端
    async function saveGraphToBackend() {
      try {
        // 获取token
        const token = localStorage.getItem('token') || sessionStorage.getItem('token');
        
        if (!token) {
          showNotification('请先登录', 'error');
          return;
        }
        
        if (!currentStoryId || currentStoryId === 'default') {
          showNotification('没有有效的故事ID', 'error');
          return;
        }
        
        let successCount = 0;
        let errorCount = 0;
        const idMap = {}; // 用于存储临时ID到后端ID的映射
        
        // 使用单个更新API逐个保存章节
        for (const node of Object.values(graphData.nodes)) {
          // 准备章节数据
          const sectionData = {
            type: node.type === 'choice' ? 'choice' : 'text',
            text: node.content,
            isEnd: node.type === 'ending',
            title: node.title || '未命名章节',
            choices: graphData.connections
              .filter(conn => conn.from === node.id)
              .map(conn => ({
                text: conn.description || '继续',
                nextSectionId: idMap[conn.to] || conn.to // 使用映射后的ID或原始ID
              }))
          };
          
          // 尝试更新或创建章节
          try {
            let response, url;
            
            // 如果是临时ID（6位数字），使用POST创建
            if (/^\d{6}$/.test(node.id)) {
              url = `http://localhost:5000/api/v1/sections/${currentStoryId}`;
              response = await fetch(url, {
                method: 'POST',
                headers: {
                  'Content-Type': 'application/json',
                  'Authorization': `Bearer ${token}`
                },
                body: JSON.stringify({
                  ...sectionData,
                  order: 1 // 简化处理
                })
              });
            } else {
              // 否则尝试更新
              url = `http://localhost:5000/api/v1/sections/${currentStoryId}/${node.id}`;
              response = await fetch(url, {
                method: 'PUT',
                headers: {
                  'Content-Type': 'application/json',
                  'Authorization': `Bearer ${token}`
                },
                body: JSON.stringify(sectionData)
              });
            }
            
            if (response.ok) {
              const result = await response.json();
              successCount++;
              
              // 如果是创建的新章节，保存ID映射
              if (result.data && result.data._id && result.data._id !== node.id) {
                idMap[node.id] = result.data._id;
                console.log(`节点ID映射: ${node.id} -> ${result.data._id}`);
              }
            } else {
              // 如果更新失败，可能是章节不存在，尝试创建
              if (response.status === 404) {
                const createResponse = await fetch(`http://localhost:5000/api/v1/sections/${currentStoryId}`, {
                  method: 'POST',
                  headers: {
                    'Content-Type': 'application/json',
                    'Authorization': `Bearer ${token}`
                  },
                  body: JSON.stringify({
                    ...sectionData,
                    order: 1
                  })
                });
                
                if (createResponse.ok) {
                  const result = await createResponse.json();
                  successCount++;
                  
                  if (result.data && result.data._id) {
                    idMap[node.id] = result.data._id;
                  }
                } else {
                  errorCount++;
                  console.error('创建章节失败:', await createResponse.text());
                }
              } else {
                errorCount++;
                console.error('更新章节失败:', await response.text());
              }
            }
          } catch (err) {
            console.error('保存章节失败:', err);
            errorCount++;
          }
        }
        
        // 如果有ID映射，更新本地数据
        if (Object.keys(idMap).length > 0) {
          // 更新节点ID
          const updatedNodes = {};
          for (const [tempId, realId] of Object.entries(idMap)) {
            if (graphData.nodes[tempId]) {
              updatedNodes[realId] = { ...graphData.nodes[tempId], id: realId };
              delete graphData.nodes[tempId];
            }
          }
          
          // 合并更新后的节点
          graphData.nodes = { ...graphData.nodes, ...updatedNodes };
          
          // 更新连接中的ID
          graphData.connections.forEach(conn => {
            if (idMap[conn.from]) conn.from = idMap[conn.from];
            if (idMap[conn.to]) conn.to = idMap[conn.to];
          });
          
          // 重新保存到本地
          saveGraphData();
          console.log('本地数据已更新为后端ID');
        }
        
        // 显示结果
        if (errorCount === 0) {
          showNotification(`成功保存全部${successCount}个章节和连接`, 'success');
        } else if (successCount > 0) {
          showNotification(`部分保存成功：${successCount}个成功，${errorCount}个失败`, 'warning');
        } else {
          showNotification('所有章节保存失败，请重试', 'error');
        }
        
      } catch (error) {
        console.error('保存到后端失败', error);
        showNotification('保存到服务器失败，但本地已保存', 'warning');
      }
    }
    
    // 导出故事
    function exportStory() {
      try {
        const story = {
          title: document.getElementById('current-story-title').textContent.replace('所属故事：', ''),
          created: new Date().toISOString(),
          graph: graphData
        };
        
        // 创建下载链接
        const dataStr = JSON.stringify(story, null, 2);
        const dataUri = 'data:application/json;charset=utf-8,' + encodeURIComponent(dataStr);
        
        const exportFileDefaultName = `${story.title || '未命名故事'}_${Date.now()}.json`;
        
        const linkElement = document.createElement('a');
        linkElement.setAttribute('href', dataUri);
        linkElement.setAttribute('download', exportFileDefaultName);
        linkElement.click();
        
        showNotification('故事已导出', 'success');
      } catch (error) {
        console.error('导出失败', error);
        showNotification('导出失败', 'error');
      }
    }
    
    // 通知功能
    function showNotification(message, type = 'info') {
      const notification = document.createElement('div');
      notification.className = `fixed bottom-4 right-4 px-4 py-3 rounded-lg shadow-lg z-50 flex items-center transition-all duration-300 transform translate-y-10 opacity-0`;
      
      if (type === 'success') {
        notification.classList.add('bg-green-50', 'border', 'border-green-200', 'text-green-700');
        notification.innerHTML = `<i class="fa fa-check-circle mr-2"></i>${message}`;
      } else if (type === 'error') {
        notification.classList.add('bg-red-50', 'border', 'border-red-200', 'text-red-700');
        notification.innerHTML = `<i class="fa fa-exclamation-circle mr-2"></i>${message}`;
      } else if (type === 'warning') {
        notification.classList.add('bg-yellow-50', 'border', 'border-yellow-200', 'text-yellow-700');
        notification.innerHTML = `<i class="fa fa-exclamation-triangle mr-2"></i>${message}`;
      } else {
        notification.classList.add('bg-blue-50', 'border', 'border-blue-200', 'text-blue-700');
        notification.innerHTML = `<i class="fa fa-info-circle mr-2"></i>${message}`;
      }
      
      document.body.appendChild(notification);
      setTimeout(() => notification.classList.remove('translate-y-10', 'opacity-0'), 10);
      setTimeout(() => {
        notification.classList.add('translate-y-10', 'opacity-0');
        setTimeout(() => notification.remove(), 300);
      }, 3000);
    }
  </script>
</body>
</html>