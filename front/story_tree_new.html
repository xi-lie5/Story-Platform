<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>故事节点图谱 - StoryForge</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <link href="https://cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css" rel="stylesheet">
  <script>
    tailwind.config = {
      theme: {
        extend: {
          colors: {
            primary: '#6366f1',
            secondary: '#ec4899',
          },
        },
      }
    }
  </script>
  <style>
    .tree-node {
      transition: all 0.3s ease;
      cursor: pointer;
      user-select: none;
    }
    .tree-node:hover {
      transform: translateY(-2px);
      box-shadow: 0 8px 25px rgba(0,0,0,0.15);
    }
    .tree-line {
      stroke: #cbd5e1;
      stroke-width: 2;
      fill: none;
    }
    .tree-line.animated {
      stroke-dasharray: 5, 5;
      animation: dash 20s linear infinite;
    }
    @keyframes dash {
      to {
        stroke-dashoffset: -100;
      }
    }
    .context-menu {
      position: fixed;
      background: white;
      border-radius: 8px;
      box-shadow: 0 4px 20px rgba(0,0,0,0.15);
      padding: 8px 0;
      z-index: 1000;
      display: none;
      min-width: 180px;
    }
    .context-menu-item {
      padding: 10px 20px;
      cursor: pointer;
      transition: background 0.2s;
      font-size: 14px;
      color: #374151;
    }
    .context-menu-item:hover {
      background: #f1f5f9;
    }
    .node-choice {
      background: #fef3c7;
      border: 2px solid #f59e0b;
      color: #92400e;
    }
    .node-ending {
      background: #dcfce7;
      border: 2px solid #22c55e;
      color: #166534;
    }
    .node-normal {
      background: #eff6ff;
      border: 2px solid #3b82f6;
      color: #1e40af;
    }
    .choice-label {
      background: #fbbf24;
      color: white;
      font-size: 12px;
      padding: 2px 8px;
      border-radius: 12px;
      margin: 2px;
      display: inline-block;
    }
    .tree-canvas {
      background-image: 
        linear-gradient(rgba(0, 0, 0, 0.03) 1px, transparent 1px),
        linear-gradient(90deg, rgba(0,0,0,0.03) 1px, transparent 1px);
      background-size: 20px 20px;
      cursor: grab;
    }
    .tree-canvas.dragging {
      cursor: grabbing;
    }
    .selected-node {
      box-shadow: 0 0 0 4px rgba(59, 130, 246, 0.5);
    }
    .line-clamp-2 {
      display: -webkit-box;
      -webkit-line-clamp: 2;
      -webkit-box-orient: vertical;
      overflow: hidden;
    }
    .navbar-modern {
      background: rgba(255,255,255,0.98);
      backdrop-filter: blur(10px);
      border-bottom: 1px solid rgba(0,0,0,0.08);
      box-shadow: 0 1px 3px rgba(0,0,0,0.05);
    }
  </style>
</head>
<body class="bg-gradient-to-br from-slate-50 to-slate-100 min-h-screen">
  <!-- 导航栏 -->
  <header class="navbar-modern fixed top-0 left-0 right-0 z-50">
    <div class="container mx-auto px-4 py-3 flex items-center justify-between">
      <div class="flex items-center space-x-2">
        <div class="w-10 h-10 bg-gradient-to-br from-primary to-secondary rounded-xl flex items-center justify-center shadow-lg">
          <i class="fa fa-book text-white text-xl"></i>
        </div>
        <h1 class="text-xl font-bold bg-gradient-to-r from-primary to-secondary bg-clip-text text-transparent">StoryForge</h1>
      </div>
      
      <nav class="hidden md:flex items-center space-x-8">
        <a href="index.html" class="font-medium text-gray-600 hover:text-primary transition-colors">首页</a>
        <a href="explore.html" class="font-medium text-gray-600 hover:text-primary transition-colors">探索故事</a>
        <a href="create.html" class="font-medium text-gray-600 hover:text-primary transition-colors">创建故事</a>
        <a href="my_stories.html" class="font-medium text-gray-600 hover:text-primary transition-colors">我的作品</a>
        <a href="about.html" class="font-medium text-gray-600 hover:text-primary transition-colors">关于</a>
      </nav>
      
      <div class="flex items-center space-x-4" id="auth-area-desktop"></div>
    </div>
  </header>

  <!-- 主要内容区 -->
  <section class="pt-20 pb-20 px-4">
    <div class="container mx-auto max-w-7xl">
      <!-- 标题与操作区 -->
      <div class="flex flex-col md:flex-row justify-between items-start md:items-center mb-6 gap-4">
        <div>
          <h2 class="text-2xl font-bold mb-2 text-gray-900">故事节点图谱</h2>
          <p class="text-gray-500">构建您的互动故事世界</p>
        </div>
        <div class="flex gap-3">
          <button id="create-root-node" class="px-4 py-2 bg-primary text-white rounded-lg hover:bg-primary/90 transition-colors flex items-center">
            <i class="fa fa-plus mr-2"></i> 创建故事开始
          </button>
          <button id="auto-layout" class="px-4 py-2 bg-white border border-gray-200 rounded-lg hover:bg-gray-50 transition-colors flex items-center">
            <i class="fa fa-magic mr-2"></i> 自动布局
          </button>
          <button id="zoom-in" class="px-3 py-2 bg-white border border-gray-200 rounded-lg hover:bg-gray-50 transition-colors">
            <i class="fa fa-search-plus"></i>
          </button>
          <button id="zoom-out" class="px-3 py-2 bg-white border border-gray-200 rounded-lg hover:bg-gray-50 transition-colors">
            <i class="fa fa-search-minus"></i>
          </button>
          <button id="zoom-reset" class="px-3 py-2 bg-white border border-gray-200 rounded-lg hover:bg-gray-50 transition-colors">
            <i class="fa fa-compress"></i>
          </button>
        </div>
      </div>

      <!-- 故事信息 -->
      <div class="bg-white rounded-xl shadow-lg p-4 mb-6">
        <div class="flex items-center justify-between">
          <div class="flex items-center space-x-4">
            <div>
              <h3 class="font-bold text-lg text-gray-900" id="current-story-title">加载中...</h3>
              <p class="text-sm text-gray-500">
                <span id="nodes-count">0</span> 个节点 · 
                <span id="tree-depth">0</span> 层深度
              </p>
            </div>
          </div>
          <div class="flex gap-2">
            <button id="toggle-complete" class="px-4 py-2 border border-gray-200 rounded-lg hover:bg-gray-50 transition-colors flex items-center">
              <i class="fa fa-check-circle mr-2"></i>
              <span id="complete-text">标记完成</span>
            </button>
          </div>
        </div>
      </div>

      <!-- 故事走向输入区 -->
      <div class="bg-white rounded-xl shadow-lg p-6 mb-6">
        <h3 class="text-lg font-semibold mb-4 text-gray-900">
          <i class="fa fa-pencil mr-2 text-primary"></i>输入故事走向
        </h3>
        <div class="flex gap-3">
          <div class="flex-1">
            <input 
              type="text" 
              id="story-direction-input" 
              class="w-full px-4 py-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-primary focus:border-primary transition-all" 
              placeholder="输入故事的大致走向，例如：主角遇到了一个神秘的老人..."
            >
            <p class="text-xs text-gray-500 mt-2">
              <i class="fa fa-info-circle mr-1"></i>每次输入后会自动创建一个节点，您可以在节点图谱中查看和编辑
            </p>
          </div>
          <button 
            id="create-node-from-input" 
            class="px-6 py-3 bg-primary text-white rounded-lg hover:bg-primary/90 transition-colors flex items-center whitespace-nowrap"
          >
            <i class="fa fa-plus mr-2"></i>创建节点
          </button>
        </div>
      </div>

      <!-- 故事树画布 -->
      <div class="bg-white rounded-xl shadow-lg overflow-hidden" style="height: 600px;">
        <div id="tree-canvas" class="tree-canvas w-full h-full relative overflow-hidden">
          <!-- 操作提示按钮 (仅在非空状态显示) -->
          <button id="help-button" class="absolute top-4 right-4 z-10 bg-blue-500 text-white p-2 rounded-full shadow-lg hover:bg-blue-600 transition-colors" style="display: none;" onclick="toggleHelp()">
            <i class="fa fa-question"></i>
          </button>
          
          <!-- 操作提示面板 -->
          <div id="help-panel" class="absolute top-16 right-4 z-10 bg-white border border-gray-200 rounded-lg shadow-xl p-4 w-80" style="display: none;">
            <div class="flex items-center justify-between mb-3">
              <h4 class="font-semibold text-gray-900">操作指南</h4>
              <button onclick="toggleHelp()" class="text-gray-400 hover:text-gray-600">
                <i class="fa fa-times"></i>
              </button>
            </div>
            <div class="space-y-2 text-sm">
              <div class="flex items-start">
                <i class="fa fa-mouse-pointer text-blue-500 mt-0.5 mr-2 w-4"></i>
                <div>
                  <strong class="text-gray-900">右键点击节点</strong>
                  <p class="text-gray-600">编辑、添加子节点、删除等操作</p>
                </div>
              </div>
              <div class="flex items-start">
                <i class="fa fa-hand-paper text-green-500 mt-0.5 mr-2 w-4"></i>
                <div>
                  <strong class="text-gray-900">拖拽画布</strong>
                  <p class="text-gray-600">按住鼠标左键拖动空白区域</p>
                </div>
              </div>
              <div class="flex items-start">
                <i class="fa fa-search-plus text-purple-500 mt-0.5 mr-2 w-4"></i>
                <div>
                  <strong class="text-gray-900">滚轮缩放</strong>
                  <p class="text-gray-600">使用鼠标滚轮放大/缩小视图</p>
                </div>
              </div>
              <div class="flex items-start">
                <i class="fa fa-arrows-alt text-orange-500 mt-0.5 mr-2 w-4"></i>
                <div>
                  <strong class="text-gray-900">拖拽节点</strong>
                  <p class="text-gray-600">按住鼠标左键拖动节点调整位置</p>
                </div>
              </div>
            </div>
          </div>
          
          <!-- SVG 连接线层 -->
          <svg id="connection-layer" class="absolute top-0 left-0 w-full h-full pointer-events-none" style="z-index: 1;">
          </svg>
          
          <!-- 节点层 -->
          <div id="nodes-layer" class="absolute top-0 left-0 w-full h-full" style="z-index: 2; transform-origin: 0 0;">
            <!-- 空状态 -->
            <div id="empty-state" class="flex flex-col items-center justify-center h-full">
              <i class="fa fa-sitemap text-6xl text-gray-300 mb-4"></i>
              <h3 class="text-xl font-semibold text-gray-600 mb-2">开始创建您的故事</h3>
              <p class="text-gray-500 mb-4">点击'创建故事开始'按钮来创建第一个节点</p>
              
              <button id="empty-create-root" class="px-6 py-3 bg-primary text-white rounded-lg hover:bg-primary/90 transition-colors flex items-center mb-6">
                <i class="fa fa-plus mr-2"></i> 创建故事开始
              </button>
              
              <!-- 操作提示 -->
              <div class="bg-blue-50 border border-blue-200 rounded-lg p-4 max-w-md">
                <div class="flex items-start">
                  <i class="fa fa-info-circle text-blue-500 mt-1 mr-3"></i>
                  <div>
                    <h4 class="font-semibold text-blue-900 mb-2">操作提示</h4>
                    <ul class="text-sm text-blue-800 space-y-1">
                      <li><i class="fa fa-mouse-pointer mr-2"></i><strong>右键点击节点</strong>：编辑、添加子节点、删除等操作</li>
                      <li><i class="fa fa-hand-paper mr-2"></i><strong>拖拽画布</strong>：移动整个故事树视图</li>
                      <li><i class="fa fa-search-plus mr-2"></i><strong>滚轮缩放</strong>：放大/缩小视图</li>
                      <li><i class="fa fa-arrows-alt mr-2"></i><strong>拖拽节点</strong>：调整节点位置</li>
                    </ul>
                  </div>
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
  </section>

  <!-- 右键菜单 -->
  <div id="context-menu" class="context-menu">
    <div class="context-menu-item" data-action="edit">
      <i class="fa fa-edit mr-2"></i> 编辑节点
    </div>
    <div class="context-menu-item" data-action="add-child">
      <i class="fa fa-plus mr-2"></i> 添加子节点
    </div>
    <div class="border-t border-gray-200 my-2"></div>
    <div class="context-menu-item" data-action="delete">
      <i class="fa fa-trash mr-2 text-red-500"></i> 删除节点
    </div>
  </div>

  <script src="assets/js/auth.js"></script>
  <script src="assets/js/api-config.js"></script>
  <script>  // 全局变量
    let currentStoryId = null;
    let graphData = {
      nodes: {},
      connections: []
    };
    let selectedNodeId = null;
    let zoomLevel = 1;
    let isDragging = false;
    let dragStartPos = { x: 0, y: 0 };
    let canvasOffset = { x: 0, y: 0 };
    let isNodeDragging = false;
    let draggedNodeId = null;

    // 初始化
    document.addEventListener('DOMContentLoaded', function() {
      initializePage();
      bindEvents();
      loadStoryData();
    });

    // 初始化页面
    function initializePage() {
      // 从URL获取故事ID
      const params = new URLSearchParams(window.location.search);
      currentStoryId = params.get('story') || 'default';
      
      // 设置画布事件
      const canvas = document.getElementById('tree-canvas');
      canvas.addEventListener('mousedown', handleCanvasMouseDown);
      canvas.addEventListener('mousemove', handleCanvasMouseMove);
      canvas.addEventListener('mouseup', handleCanvasMouseUp);
      canvas.addEventListener('mouseleave', handleCanvasMouseUp);
      canvas.addEventListener('wheel', handleCanvasWheel);
    }

    // 绑定事件
    function bindEvents() {
      // 创建根节点
      document.getElementById('create-root-node').addEventListener('click', createRootNode);
      document.getElementById('empty-create-root').addEventListener('click', createRootNode);
      
      // 从输入框创建节点
      document.getElementById('create-node-from-input').addEventListener('click', createNodeFromInput);
      
      // 输入框回车键创建节点
      document.getElementById('story-direction-input').addEventListener('keypress', function(e) {
        if (e.key === 'Enter') {
          e.preventDefault();
          createNodeFromInput();
        }
      });
      
      // 自动布局
      document.getElementById('auto-layout').addEventListener('click', autoLayout);
      
      // 缩放控制
      document.getElementById('zoom-in').addEventListener('click', () => zoom(1.2));
      document.getElementById('zoom-out').addEventListener('click', () => zoom(0.8));
      document.getElementById('zoom-reset').addEventListener('click', resetZoom);
      
      // 完成状态切换
      document.getElementById('toggle-complete').addEventListener('click', toggleComplete);
      
      // 右键菜单
      document.addEventListener('contextmenu', handleContextMenu);
      document.addEventListener('click', hideContextMenu);
      
      // 右键菜单项点击
      document.querySelectorAll('.context-menu-item').forEach(item => {
        item.addEventListener('click', handleContextMenuAction);
      });
    }

    // 加载故事数据
    async function loadStoryData() {
      try {
        // 如果有故事ID，优先从后端加载
        if (currentStoryId !== 'default') {
          await loadFromBackend();
          // 如果后端加载成功，使用后端数据；否则使用本地数据
          if (Object.keys(graphData.nodes).length === 0) {
            const savedData = localStorage.getItem('storyGraphData');
            if (savedData) {
              graphData = JSON.parse(savedData);
            }
          }
        } else {
          // 从本地存储获取数据
          const savedData = localStorage.getItem('storyGraphData');
          if (savedData) {
            graphData = JSON.parse(savedData);
          }
        }
        
        // 加载故事信息
        await loadStoryInfo();
        
        // 渲染树状图
        renderTree();
        updateStoryInfo();
      } catch (error) {
        console.error('加载故事数据失败:', error);
        showNotification('加载故事数据失败', 'error');
      }
    }

    // 从后端加载数据
    async function loadFromBackend() {
      try {
        const token = localStorage.getItem('token') || sessionStorage.getItem('token');
        if (!token || currentStoryId === 'default') return;
        
        // 使用新的节点API加载数据
        const response = await fetch(API_CONFIG.NODES.getStoryNodes(currentStoryId), {
          headers: API_CONFIG.getAuthHeaders()
        });
        
        if (response.ok) {
          const result = await response.json();
          if (result.success && result.data && result.data.length > 0) {
            // 转换后端数据为前端格式
            convertBackendData(result.data);
            
            // 加载故事信息
            await loadStoryInfo();
          }
        }
      } catch (error) {
        console.error('从后端加载数据失败:', error);
      }
    }

    // 加载故事信息
    async function loadStoryInfo() {
      try {
        const token = localStorage.getItem('token') || sessionStorage.getItem('token');
        if (!token || currentStoryId === 'default') return;
        
        const response = await fetch(API_CONFIG.STORIES.getStory(currentStoryId), {
          headers: API_CONFIG.getAuthHeaders()
        });
        
        if (response.ok) {
          const result = await response.json();
          if (result.success && result.data) {
            const story = result.data;
            document.getElementById('current-story-title').textContent = story.title || `故事 #${currentStoryId.slice(-6)}`;
          }
        }
      } catch (error) {
        console.error('加载故事信息失败:', error);
      }
    }

    // 转换后端数据格式
    function convertBackendData(nodes) {
      graphData = {
        nodes: {},
        connections: []
      };
      
      nodes.forEach(node => {
        const nodeId = node._id || node.id;
        graphData.nodes[nodeId] = {
          id: nodeId,
          title: node.title || '未命名节点',
          content: node.content || '',
          type: node.type || 'normal',
          position: node.position || { 
            x: Math.random() * 400 + 200, 
            y: Math.random() * 300 + 100 
          },
          depth: node.depth || 0,
          order: node.order || 0
        };
        
        // 添加连接关系 - 统一处理choices数组
        if (node.choices && node.choices.length > 0) {
          node.choices.forEach(choice => {
            const targetId = choice.targetNodeId?._id || choice.targetNodeId;
            if (targetId) {
              graphData.connections.push({
                from: nodeId,
                to: targetId.toString(),
                description: choice.text || '继续'
              });
            }
          });
        }
      });
    }

    // 从输入框创建节点
    async function createNodeFromInput() {
      const input = document.getElementById('story-direction-input');
      const direction = input.value.trim();
      
      if (!direction) {
        showNotification('请输入故事走向', 'error');
        input.focus();
        return;
      }
      
      // 检查是否有根节点
      const nodeIds = Object.keys(graphData.nodes);
      if (nodeIds.length === 0) {
        // 如果没有节点，先创建根节点
        await createRootNode();
      }
      
      // 确定父节点（如果有选中的节点，使用选中的节点；否则使用最后一个节点）
      let parentNodeId = selectedNodeId;
      if (!parentNodeId) {
        // 找到最后一个节点作为父节点
        const nodes = Object.values(graphData.nodes);
        if (nodes.length > 0) {
          parentNodeId = nodes[nodes.length - 1].id;
        }
      }
      
      try {
        const token = localStorage.getItem('token') || sessionStorage.getItem('token');
        if (!token) {
          showNotification('请先登录', 'error');
          return;
        }
        
        // 创建节点数据
        const newNode = {
          title: direction.length > 20 ? direction.substring(0, 20) + '...' : direction,
          content: direction,
          type: 'normal',
          position: { 
            x: parentNodeId && graphData.nodes[parentNodeId] 
              ? graphData.nodes[parentNodeId].position.x + (Math.random() - 0.5) * 200
              : Math.random() * 400 + 200, 
            y: parentNodeId && graphData.nodes[parentNodeId]
              ? graphData.nodes[parentNodeId].position.y + 150
              : Math.random() * 300 + 100
          }
        };
        
        // 如果有父节点，通过API创建子节点
        if (parentNodeId && currentStoryId !== 'default') {
          try {
            const response = await fetch(API_CONFIG.NODES.createNode(currentStoryId), {
              method: 'POST',
              headers: API_CONFIG.getAuthHeaders(),
              body: JSON.stringify({
                parentId: parentNodeId,
                title: newNode.title,
                content: newNode.content,
                type: newNode.type
              })
            });
            
            if (response.ok) {
              const result = await response.json();
              if (result.success) {
                const savedNode = result.data;
                newNode.id = savedNode._id || savedNode.id;
                newNode.position = savedNode.position || newNode.position;
                
                // 添加到图数据
                graphData.nodes[newNode.id] = newNode;
                
                // 如果有父节点，添加连接
                if (parentNodeId) {
                  graphData.connections.push({
                    from: parentNodeId,
                    to: newNode.id,
                    description: '继续'
                  });
                }
                
                // 保存数据
                saveGraphData();
                
                // 重新渲染
                renderTree();
                updateStoryInfo();
                
                // 清空输入框
                input.value = '';
                
                showNotification('节点创建成功', 'success');
                return;
              }
            }
          } catch (error) {
            console.error('通过API创建节点失败:', error);
            // 继续使用本地创建方式
          }
        }
        
        // 本地创建节点（如果API失败或没有父节点）
        newNode.id = 'node-' + Date.now();
        graphData.nodes[newNode.id] = newNode;
        
        // 如果有父节点，添加连接
        if (parentNodeId) {
          graphData.connections.push({
            from: parentNodeId,
            to: newNode.id,
            description: '继续'
          });
        }
        
        // 保存数据
        saveGraphData();
        
        // 重新渲染
        renderTree();
        updateStoryInfo();
        
        // 清空输入框
        input.value = '';
        
        showNotification('节点创建成功', 'success');
      } catch (error) {
        console.error('创建节点失败:', error);
        showNotification('创建节点失败', 'error');
      }
    }

    // 创建根节点
    async function createRootNode() {
      try {
        const token = localStorage.getItem('token') || sessionStorage.getItem('token');
        if (!token) {
          showNotification('请先登录', 'error');
          return;
        }

        // 检查是否已有根节点
        const nodeIds = Object.keys(graphData.nodes);
        if (nodeIds.length > 0) {
          showNotification('根节点已存在', 'info');
          return;
        }

        // 如果有故事ID，通过API创建根节点
        if (currentStoryId !== 'default') {
          try {
            const rootUrl = API_CONFIG.NODES.createNode(currentStoryId).replace('/nodes', '/root');
            const response = await fetch(rootUrl, {
              method: 'POST',
              headers: API_CONFIG.getAuthHeaders(),
              body: JSON.stringify({
                title: '故事开始',
                content: '这是故事的开始...'
              })
            });
            
            if (response.ok) {
              const result = await response.json();
              if (result.success) {
                const savedNode = result.data;
                const rootNode = {
                  id: savedNode._id || savedNode.id,
                  title: savedNode.title || '故事开始',
                  content: savedNode.content || '这是故事的开始...',
                  type: savedNode.type || 'normal',
                  position: savedNode.position || { x: 400, y: 50 },
                  depth: savedNode.depth || 0,
                  order: savedNode.order || 0
                };
                
                // 添加到图数据
                graphData.nodes[rootNode.id] = rootNode;
                
                // 保存数据
                saveGraphData();
                
                // 重新渲染
                renderTree();
                updateStoryInfo();
                
                showNotification('根节点创建成功', 'success');
                return;
              }
            }
          } catch (error) {
            console.error('通过API创建根节点失败:', error);
            // 继续使用本地创建方式
          }
        }

        // 本地创建根节点
        const rootNode = {
          id: 'node-' + Date.now(),
          title: '故事开始',
          content: '这是故事的开始...',
          type: 'normal',
          position: { x: 400, y: 50 },
          depth: 0,
          order: 0
        };

        // 添加到图数据
        graphData.nodes[rootNode.id] = rootNode;

        // 保存数据
        saveGraphData();

        // 重新渲染
        renderTree();
        updateStoryInfo();
        
        showNotification('根节点创建成功', 'success');
      } catch (error) {
        console.error('创建根节点失败:', error);
        showNotification('创建根节点失败', 'error');
      }
    }

    // 渲染树状图
    function renderTree() {
      const nodesLayer = document.getElementById('nodes-layer');
      const connectionLayer = document.getElementById('connection-layer');
      const emptyState = document.getElementById('empty-state');
      const helpButton = document.getElementById('help-button');
      
      // 清空现有内容
      nodesLayer.innerHTML = '';
      connectionLayer.innerHTML = '';
      
      const nodeIds = Object.keys(graphData.nodes);
      
      if (nodeIds.length === 0) {
        nodesLayer.appendChild(emptyState.cloneNode(true));
        // 隐藏帮助按钮
        if (helpButton) helpButton.style.display = 'none';
        return;
      }
      
      // 显示帮助按钮
      if (helpButton) helpButton.style.display = 'block';
      
      // 绘制连接线
      graphData.connections.forEach(conn => {
        drawConnection(conn);
      });
      
      // 绘制节点
      nodeIds.forEach(nodeId => {
        drawNode(graphData.nodes[nodeId]);
      });
    }

    // 切换帮助面板显示
    function toggleHelp() {
      const helpPanel = document.getElementById('help-panel');
      if (helpPanel.style.display === 'none' || !helpPanel.style.display) {
        helpPanel.style.display = 'block';
      } else {
        helpPanel.style.display = 'none';
      }
    }

    // 绘制节点
    function drawNode(node) {
      const nodesLayer = document.getElementById('nodes-layer');
      const nodeEl = document.createElement('div');
      
      nodeEl.className = `tree-node absolute bg-white rounded-lg shadow-lg p-4 select-none ${getNodeClass(node.type)}`;
      nodeEl.id = `node-${node.id}`;
      nodeEl.style.left = `${node.position.x}px`;
      nodeEl.style.top = `${node.position.y}px`;
      nodeEl.style.width = '200px';
      
      nodeEl.innerHTML = `
        <div class="flex items-center justify-between mb-2">
          <span class="text-xs font-medium px-2 py-1 rounded-full ${getTypeBadgeClass(node.type)}">
            ${getTypeLabel(node.type)}
          </span>
          <button class="text-gray-400 hover:text-gray-600" onclick="event.stopPropagation()">
            <i class="fa fa-ellipsis-v text-xs"></i>
          </button>
        </div>
        <h4 class="font-medium text-sm mb-1 truncate text-gray-900">${node.title}</h4>
        <p class="text-xs text-gray-500 line-clamp-2">${node.content || '暂无内容'}</p>
      `;
      
      // 添加事件监听
      nodeEl.addEventListener('click', (e) => {
        e.stopPropagation();
        selectNode(node.id);
      });
      nodeEl.addEventListener('mousedown', (e) => startDragNode(e, node.id));
      nodeEl.addEventListener('contextmenu', (e) => showContextMenu(e, node.id));
      
      nodesLayer.appendChild(nodeEl);
    }

    // 绘制连接线
    function drawConnection(conn) {
      const svg = document.getElementById('connection-layer');
      const fromNode = graphData.nodes[conn.from];
      const toNode = graphData.nodes[conn.to];
      
      if (!fromNode || !toNode) return;
      
      const line = document.createElementNS('http://www.w3.org/2000/svg', 'path');
      const fromX = fromNode.position.x + 100;
      const fromY = fromNode.position.y + 60;
      const toX = toNode.position.x + 100;
      const toY = toNode.position.y;
      
      const midY = (fromY + toY) / 2;
      const d = `M ${fromX} ${fromY} C ${fromX} ${midY}, ${toX} ${midY}, ${toX} ${toY}`;
      
      line.setAttribute('d', d);
      line.setAttribute('class', 'tree-line animated');
      line.setAttribute('marker-end', 'url(#arrowhead)');
      
      svg.appendChild(line);
    }

    // 获取节点样式类
    function getNodeClass(type) {
      switch (type) {
        case 'choice': return 'node-choice';
        case 'ending': return 'node-ending';
        default: return 'node-normal';
      }
    }

    // 获取类型标签样式
    function getTypeBadgeClass(type) {
      switch (type) {
        case 'choice': return 'bg-amber-100 text-amber-800';
        case 'ending': return 'bg-green-100 text-green-800';
        default: return 'bg-blue-100 text-blue-800';
      }
    }

    // 获取类型标签文本
    function getTypeLabel(type) {
      switch (type) {
        case 'choice': return '选择';
        case 'ending': return '结局';
        default: return '章节';
      }
    }

    // 选择节点
    function selectNode(nodeId) {
      selectedNodeId = nodeId;
      
      // 更新选中状态
      document.querySelectorAll('.tree-node').forEach(el => {
        el.classList.remove('selected-node');
      });
      
      const selectedEl = document.getElementById(`node-${nodeId}`);
      if (selectedEl) {
        selectedEl.classList.add('selected-node');
      }
    }

    // 显示右键菜单
    function showContextMenu(e, nodeId) {
      e.preventDefault();
      e.stopPropagation();
      selectedNodeId = nodeId;
      
      const menu = document.getElementById('context-menu');
      menu.style.display = 'block';
      menu.style.left = `${e.clientX}px`;
      menu.style.top = `${e.clientY}px`;
    }

    // 处理右键菜单事件
    function handleContextMenu(e) {
      // 如果点击的是节点，显示节点菜单
      const nodeEl = e.target.closest('.tree-node');
      if (nodeEl) {
        const nodeId = nodeEl.id.replace('node-', '');
        showContextMenu(e, nodeId);
        return;
      }
      
      // 否则隐藏菜单
      hideContextMenu();
    }

    // 隐藏右键菜单
    function hideContextMenu() {
      document.getElementById('context-menu').style.display = 'none';
    }

    // 处理右键菜单操作
    function handleContextMenuAction(e) {
      const action = e.currentTarget.dataset.action;
      const nodeId = selectedNodeId;
      
      switch (action) {
        case 'edit':
          editNode(nodeId);
          break;
        case 'add-child':
          addChildNode(nodeId);
          break;
        case 'delete':
          deleteNode(nodeId);
          break;
      }
      
      hideContextMenu();
    }

    // 编辑节点
    function editNode(nodeId) {
      window.location.href = `story_editor_new.html?node=${nodeId}&story=${currentStoryId}&returnTo=story_tree_new.html`;
    }

    // 添加子节点
    function addChildNode(parentId) {
      const nodeId = Date.now().toString();
      const parentNode = graphData.nodes[parentId];
      
      const newNode = {
        id: nodeId,
        title: '新章节',
        content: '',
        type: 'normal',
        position: { 
          x: parentNode.position.x + (Math.random() - 0.5) * 100,
          y: parentNode.position.y + 120
        }
      };
      
      graphData.nodes[nodeId] = newNode;
      graphData.connections.push({
        from: parentId,
        to: nodeId,
        description: '继续'
      });
      
      saveGraphData();
      renderTree();
      updateStoryInfo();
      
      showNotification('子节点添加成功', 'success');
    }

    // 删除节点
    function deleteNode(nodeId) {
      if (!confirm('确定要删除这个节点吗？此操作不可恢复。')) return;
      
      // 删除节点
      delete graphData.nodes[nodeId];
      
      // 删除相关连接
      graphData.connections = graphData.connections.filter(
        conn => conn.from !== nodeId && conn.to !== nodeId
      );
      
      saveGraphData();
      renderTree();
      updateStoryInfo();
      
      showNotification('节点删除成功', 'success');
    }

    // 自动布局
    function autoLayout() {
      const nodeIds = Object.keys(graphData.nodes);
      if (nodeIds.length === 0) return;
      
      // 简单的树状布局算法
      const levels = {};
      const visited = new Set();
      
      // 找到根节点
      const rootNodes = nodeIds.filter(id => 
        !graphData.connections.some(conn => conn.to === id)
      );
      
      // BFS分层
      const queue = rootNodes.map(id => ({ id, level: 0 }));
      
      while (queue.length > 0) {
        const { id, level } = queue.shift();
        
        if (visited.has(id)) continue;
        visited.add(id);
        
        if (!levels[level]) levels[level] = [];
        levels[level].push(id);
        
        // 找到子节点
        const children = graphData.connections
          .filter(conn => conn.from === id)
          .map(conn => conn.to);
        
        children.forEach(childId => {
          queue.push({ id: childId, level: level + 1 });
        });
      }
      
      // 重新定位节点
      Object.keys(levels).forEach(level => {
        const nodes = levels[level];
        const levelY = parseInt(level) * 150 + 50;
        const totalWidth = nodes.length * 250;
        const startX = (800 - totalWidth) / 2;
        
        nodes.forEach((nodeId, index) => {
          graphData.nodes[nodeId].position = {
            x: startX + index * 250,
            y: levelY
          };
        });
      });
      
      saveGraphData();
      renderTree();
      
      showNotification('自动布局完成', 'success');
    }

    // 缩放功能
    function zoom(factor) {
      zoomLevel *= factor;
      zoomLevel = Math.max(0.3, Math.min(3, zoomLevel));
      updateCanvasTransform();
    }

    function resetZoom() {
      zoomLevel = 1;
      canvasOffset = { x: 0, y: 0 };
      updateCanvasTransform();
    }

    // 更新画布变换
    function updateCanvasTransform() {
      const nodesLayer = document.getElementById('nodes-layer');
      const connectionLayer = document.getElementById('connection-layer');
      const transform = `translate(${canvasOffset.x}px, ${canvasOffset.y}px) scale(${zoomLevel})`;
      
      nodesLayer.style.transform = transform;
      nodesLayer.style.transformOrigin = '0 0';
      connectionLayer.style.transform = transform;
      connectionLayer.style.transformOrigin = '0 0';
    }

    // 画布拖拽功能
    function handleCanvasMouseDown(e) {
      if (e.target.id === 'tree-canvas' || e.target.id === 'nodes-layer' || e.target.id === 'connection-layer') {
        isDragging = true;
        dragStartPos = { x: e.clientX - canvasOffset.x, y: e.clientY - canvasOffset.y };
        document.getElementById('tree-canvas').classList.add('dragging');
        e.preventDefault();
      }
    }

    function handleCanvasMouseMove(e) {
      if (isDragging) {
        canvasOffset.x = e.clientX - dragStartPos.x;
        canvasOffset.y = e.clientY - dragStartPos.y;
        updateCanvasTransform();
      }
    }

    function handleCanvasMouseUp() {
      isDragging = false;
      document.getElementById('tree-canvas').classList.remove('dragging');
    }

    function handleCanvasWheel(e) {
      e.preventDefault();
      
      const canvas = document.getElementById('tree-canvas');
      const rect = canvas.getBoundingClientRect();
      
      // 获取鼠标在画布中的位置
      const mouseX = e.clientX - rect.left;
      const mouseY = e.clientY - rect.top;
      
      // 计算缩放前的世界坐标
      const worldX = (mouseX - canvasOffset.x) / zoomLevel;
      const worldY = (mouseY - canvasOffset.y) / zoomLevel;
      
      // 应用缩放
      const delta = e.deltaY > 0 ? 0.9 : 1.1;
      const newZoomLevel = Math.max(0.3, Math.min(3, zoomLevel * delta));
      
      // 计算缩放后的偏移量，使鼠标位置保持在相同的世界坐标
      canvasOffset.x = mouseX - worldX * newZoomLevel;
      canvasOffset.y = mouseY - worldY * newZoomLevel;
      zoomLevel = newZoomLevel;
      
      updateCanvasTransform();
    }

    // 节点拖拽功能
    function startDragNode(e, nodeId) {
      if (e.button !== 0) return; // 只响应左键
      
      e.stopPropagation();
      isNodeDragging = true;
      draggedNodeId = nodeId;
      
      const node = graphData.nodes[nodeId];
      const rect = e.target.getBoundingClientRect();
      const offsetX = e.clientX - rect.left;
      const offsetY = e.clientY - rect.top;
      
      function handleMouseMove(e) {
        if (!isNodeDragging) return;
        
        // 计算节点在画布中的新位置
        const canvasRect = document.getElementById('tree-canvas').getBoundingClientRect();
        const x = (e.clientX - canvasRect.left - canvasOffset.x - offsetX) / zoomLevel;
        const y = (e.clientY - canvasRect.top - canvasOffset.y - offsetY) / zoomLevel;
        
        node.position.x = x;
        node.position.y = y;
        
        const nodeEl = document.getElementById(`node-${nodeId}`);
        if (nodeEl) {
          nodeEl.style.left = `${x}px`;
          nodeEl.style.top = `${y}px`;
        }
        
        // 重新绘制连接线
        renderTree();
      }
      
      function handleMouseUp() {
        isNodeDragging = false;
        draggedNodeId = null;
        saveGraphData();
        document.removeEventListener('mousemove', handleMouseMove);
        document.removeEventListener('mouseup', handleMouseUp);
      }
      
      document.addEventListener('mousemove', handleMouseMove);
      document.addEventListener('mouseup', handleMouseUp);
    }

    // 更新故事信息
    function updateStoryInfo() {
      const nodeCount = Object.keys(graphData.nodes).length;
      const depth = calculateTreeDepth();
      
      document.getElementById('nodes-count').textContent = nodeCount;
      document.getElementById('tree-depth').textContent = depth;
      
      // 更新故事标题
      const titleEl = document.getElementById('current-story-title');
      if (titleEl && currentStoryId !== 'default') {
        titleEl.textContent = `故事 #${currentStoryId.slice(-6)}`;
      }
    }

    // 计算树深度
    function calculateTreeDepth() {
      const nodeIds = Object.keys(graphData.nodes);
      if (nodeIds.length === 0) return 0;
      
      const visited = new Set();
      let maxDepth = 0;
      
      function dfs(nodeId, depth) {
        if (visited.has(nodeId)) return;
        visited.add(nodeId);
        
        maxDepth = Math.max(maxDepth, depth);
        
        const children = graphData.connections
          .filter(conn => conn.from === nodeId)
          .map(conn => conn.to);
        
        children.forEach(childId => dfs(childId, depth + 1));
      }
      
      // 找到根节点并开始DFS
      const rootNodes = nodeIds.filter(id => 
        !graphData.connections.some(conn => conn.to === id)
      );
      
      rootNodes.forEach(rootId => dfs(rootId, 1));
      
      return maxDepth;
    }

    // 切换完成状态
    async function toggleComplete() {
      try {
        const token = localStorage.getItem('token') || sessionStorage.getItem('token');
        if (!token || currentStoryId === 'default') {
          showNotification('请先登录', 'error');
          return;
        }
        
        const response = await fetch(`http://localhost:5000/api/v1/stories/${currentStoryId}/toggle-complete`, {
          method: 'PUT',
          headers: {
            'Authorization': `Bearer ${token}`
          }
        });
        
        if (response.ok) {
          const result = await response.json();
          const isCompleted = result.data.isCompleted;
          
          const btn = document.getElementById('toggle-complete');
          const text = document.getElementById('complete-text');
          
          if (isCompleted) {
            text.textContent = '取消标记完成';
            btn.classList.add('bg-green-50', 'border-green-200', 'text-green-700');
          } else {
            text.textContent = '标记完成';
            btn.classList.remove('bg-green-50', 'border-green-200', 'text-green-700');
          }
          
          showNotification(isCompleted ? '故事已标记为完成' : '已取消完成标记', 'success');
        }
      } catch (error) {
        console.error('切换完成状态失败:', error);
        showNotification('操作失败', 'error');
      }
    }

    // 保存数据
    function saveGraphData() {
      localStorage.setItem('storyGraphData', JSON.stringify(graphData));
      
      // 异步同步到后端
      syncToBackend();
    }

    // 同步到后端
    async function syncToBackend() {
      try {
        const token = localStorage.getItem('token') || sessionStorage.getItem('token');
        if (!token || currentStoryId === 'default') return;
        
        // 将前端节点数据转换为后端格式
        const nodes = Object.values(graphData.nodes).map(node => ({
          tempId: node.id,
          title: node.title,
          content: node.content,
          type: node.type || 'normal',
          position: node.position || { x: 0, y: 0 },
          choices: graphData.connections
            .filter(conn => conn.from === node.id)
            .map(conn => ({
              id: `choice_${conn.from}_${conn.to}`,
              text: conn.description || '继续',
              tempTargetNodeId: conn.to
            }))
        }));
        
        // 使用批量保存API
        const response = await fetch(API_CONFIG.NODES.batchSave(currentStoryId), {
          method: 'POST',
          headers: API_CONFIG.getAuthHeaders(),
          body: JSON.stringify({ nodes })
        });
        
        if (response.ok) {
          const result = await response.json();
          if (result.success) {
            console.log('节点数据已保存到数据库:', result);
            // 更新节点ID映射
            if (result.data && result.data.length > 0) {
              result.data.forEach((savedNode, index) => {
                const originalNode = nodes[index];
                if (originalNode && graphData.nodes[originalNode.tempId]) {
                  const oldId = originalNode.tempId;
                  const newId = savedNode._id || savedNode.id;
                  if (oldId !== newId) {
                    graphData.nodes[newId] = graphData.nodes[oldId];
                    graphData.nodes[newId].id = newId;
                    delete graphData.nodes[oldId];
                    
                    // 更新连接中的ID
                    graphData.connections.forEach(conn => {
                      if (conn.from === oldId) conn.from = newId;
                      if (conn.to === oldId) conn.to = newId;
                    });
                  }
                }
              });
            }
            // 不显示通知，避免频繁提示
            // showNotification('数据已自动保存', 'success');
          }
        } else {
          const error = await response.json();
          console.error('保存失败:', error);
          // 不显示错误通知，避免干扰用户
          // showNotification('保存失败: ' + (error.message || '未知错误'), 'error');
        }
      } catch (error) {
        console.error('同步到后端失败:', error);
        // 不显示错误通知，避免干扰用户
        // showNotification('网络错误，保存失败', 'error');
      }
    }

    // 通知功能
    function showNotification(message, type = 'info') {
      const notification = document.createElement('div');
      notification.className = `fixed bottom-4 right-4 px-4 py-3 rounded-lg shadow-lg z-50 flex items-center transition-all duration-300 transform translate-y-10 opacity-0`;
      
      if (type === 'success') {
        notification.classList.add('bg-green-50', 'border', 'border-green-200', 'text-green-700');
        notification.innerHTML = `<i class="fa fa-check-circle mr-2"></i>${message}`;
      } else if (type === 'error') {
        notification.classList.add('bg-red-50', 'border', 'border-red-200', 'text-red-700');
        notification.innerHTML = `<i class="fa fa-exclamation-circle mr-2"></i>${message}`;
      } else {
        notification.classList.add('bg-blue-50', 'border', 'border-blue-200', 'text-blue-700');
        notification.innerHTML = `<i class="fa fa-info-circle mr-2"></i>${message}`;
      }
      
      document.body.appendChild(notification);
      setTimeout(() => notification.classList.remove('translate-y-10', 'opacity-0'), 10);
      setTimeout(() => {
        notification.classList.add('translate-y-10', 'opacity-0');
        setTimeout(() => notification.remove(), 300);
      }, 3000);
    }
  </script>
</body>
</html>